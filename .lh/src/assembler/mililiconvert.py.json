{
    "sourceFile": "src/assembler/mililiconvert.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1760304849647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760304857304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,204 @@\n+from __future__ import annotations\r\n+import ykcc.src.util as util\r\n+\r\n+class Register(object):\r\n+    def __init__(self, number:int) -> None:\r\n+        self.number = number\r\n+    def __repr__(self) -> str:\r\n+        return f\"r{self.number}\"\r\n+\r\n+class Literal(object):\r\n+    def __init__(self, value:int) -> None:\r\n+        self.value = value\r\n+    def __repr__(self) -> str:\r\n+        return str(self.value)\r\n+\r\n+class Token(object):\r\n+    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n+        self.name = name\r\n+        self.order = order\r\n+    def __repr__(self) -> str:\r\n+        if self.order:\r\n+            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n+        return self.name\r\n+\r\n+def lexer(Source:str) -> list[list[str]]:\r\n+    Tokens:list[list[str]] = []\r\n+    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n+    return Tokens\r\n+\r\n+def args(arg:list[str]) -> list[Literal | Register]:\r\n+    a:list[Literal | Register] = []\r\n+    for i in arg:\r\n+        if i[0] == \"r\" and i[1::].isdecimal():\r\n+            a.append(Register(int(i[1::])))\r\n+        elif i.isdecimal():\r\n+            a.append(Literal(int(i)))\r\n+        elif i[0] == \";\":\r\n+            break\r\n+        else:\r\n+            print(\"error\")\r\n+    return a\r\n+\r\n+def parse(Source:list[list[str]]) -> list[Token]:\r\n+    Tokens:list[Token] = []\r\n+    for i in Source:\r\n+        print(i)\r\n+        if i == []:\r\n+            return []\r\n+        if i[0][0] == \";\":\r\n+            continue\r\n+        tok:Token = Token(i[0], args(i[1::]))\r\n+        Tokens.append(tok)\r\n+    return Tokens\r\n+\r\n+def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n+    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n+    if types is not None and type(tok) is not types:\r\n+        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n+    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n+    if isinstance(tok, Literal):\r\n+        # 2桁の16進（ゼロパディング）\r\n+        return format(tok.value & 0xff, '02x')\r\n+    if isinstance(tok, Register):\r\n+        return format(tok.number & 0xf, 'x')\r\n+    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n+\r\n+def conversion(Tokens:list[Token]):\r\n+    out:str = \"\"\r\n+    for i in Tokens:\r\n+        print(i)\r\n+        match (i.name.upper()):\r\n+            case \"ADD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"0\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUB\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"1\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"ADDI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"2\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUBI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"3\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"NAND\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"4\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SHIFT\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n+                    # OK\r\n+                    out += \"5\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += hex(i.order[2].value & 0xf)[2::]\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"STORE\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"6\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"LOAD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"7\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"BRANCH\":\r\n+                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"8\"\r\n+                    out += hex(i.order[0].value & 0xf)[2::]\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"TIMER\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"9\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"RET\":\r\n+                # OK\r\n+                out += \"A\"\r\n+                out += \"000\"\r\n+            case \"HALT\":\r\n+                # OK\r\n+                out += \"B\"\r\n+                out += \"000\"\r\n+            case _:\r\n+                print(\"Error!\")\r\n+                return \"\"\r\n+    return out\r\n+\r\n+\"\"\"\r\n+ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n+SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n+ADDI r1 , n2          ; r1 = r2 + nn\r\n+SUBI r1 , n2          ; r1 = r2 - nn\r\n+NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n+SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n+STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n+LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n+BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n+TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n+RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n+HALT                  ; 停止\r\n+\"\"\"\r\n+\r\n+if __name__ == \"__main__\":\r\n+    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n+    lexed = lexer(source)\r\n+    parsed = parse(lexed)\r\n+    res = conversion(parsed)\r\n+    with open(\"out.bin\", \"w\") as f:\r\n+        f.write(res)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760304877090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,204 @@\n+from __future__ import annotations\r\n+import .util as util\r\n+\r\n+class Register(object):\r\n+    def __init__(self, number:int) -> None:\r\n+        self.number = number\r\n+    def __repr__(self) -> str:\r\n+        return f\"r{self.number}\"\r\n+\r\n+class Literal(object):\r\n+    def __init__(self, value:int) -> None:\r\n+        self.value = value\r\n+    def __repr__(self) -> str:\r\n+        return str(self.value)\r\n+\r\n+class Token(object):\r\n+    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n+        self.name = name\r\n+        self.order = order\r\n+    def __repr__(self) -> str:\r\n+        if self.order:\r\n+            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n+        return self.name\r\n+\r\n+def lexer(Source:str) -> list[list[str]]:\r\n+    Tokens:list[list[str]] = []\r\n+    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n+    return Tokens\r\n+\r\n+def args(arg:list[str]) -> list[Literal | Register]:\r\n+    a:list[Literal | Register] = []\r\n+    for i in arg:\r\n+        if i[0] == \"r\" and i[1::].isdecimal():\r\n+            a.append(Register(int(i[1::])))\r\n+        elif i.isdecimal():\r\n+            a.append(Literal(int(i)))\r\n+        elif i[0] == \";\":\r\n+            break\r\n+        else:\r\n+            print(\"error\")\r\n+    return a\r\n+\r\n+def parse(Source:list[list[str]]) -> list[Token]:\r\n+    Tokens:list[Token] = []\r\n+    for i in Source:\r\n+        print(i)\r\n+        if i == []:\r\n+            return []\r\n+        if i[0][0] == \";\":\r\n+            continue\r\n+        tok:Token = Token(i[0], args(i[1::]))\r\n+        Tokens.append(tok)\r\n+    return Tokens\r\n+\r\n+def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n+    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n+    if types is not None and type(tok) is not types:\r\n+        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n+    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n+    if isinstance(tok, Literal):\r\n+        # 2桁の16進（ゼロパディング）\r\n+        return format(tok.value & 0xff, '02x')\r\n+    if isinstance(tok, Register):\r\n+        return format(tok.number & 0xf, 'x')\r\n+    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n+\r\n+def conversion(Tokens:list[Token]):\r\n+    out:str = \"\"\r\n+    for i in Tokens:\r\n+        print(i)\r\n+        match (i.name.upper()):\r\n+            case \"ADD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"0\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUB\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"1\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"ADDI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"2\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUBI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"3\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"NAND\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"4\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SHIFT\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n+                    # OK\r\n+                    out += \"5\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += hex(i.order[2].value & 0xf)[2::]\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"STORE\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"6\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"LOAD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"7\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"BRANCH\":\r\n+                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"8\"\r\n+                    out += hex(i.order[0].value & 0xf)[2::]\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"TIMER\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"9\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"RET\":\r\n+                # OK\r\n+                out += \"A\"\r\n+                out += \"000\"\r\n+            case \"HALT\":\r\n+                # OK\r\n+                out += \"B\"\r\n+                out += \"000\"\r\n+            case _:\r\n+                print(\"Error!\")\r\n+                return \"\"\r\n+    return out\r\n+\r\n+\"\"\"\r\n+ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n+SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n+ADDI r1 , n2          ; r1 = r2 + nn\r\n+SUBI r1 , n2          ; r1 = r2 - nn\r\n+NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n+SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n+STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n+LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n+BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n+TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n+RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n+HALT                  ; 停止\r\n+\"\"\"\r\n+\r\n+if __name__ == \"__main__\":\r\n+    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n+    lexed = lexer(source)\r\n+    parsed = parse(lexed)\r\n+    res = conversion(parsed)\r\n+    with open(\"out.bin\", \"w\") as f:\r\n+        f.write(res)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760304883085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n from __future__ import annotations\r\n-import .util as util\r\n+import /.util as util\r\n \r\n class Register(object):\r\n     def __init__(self, number:int) -> None:\r\n         self.number = number\r\n"
                },
                {
                    "date": 1760304962850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,413 +1,5 @@\n from __future__ import annotations\r\n-import /.util as util\r\n-\r\n-class Register(object):\r\n-    def __init__(self, number:int) -> None:\r\n-        self.number = number\r\n-    def __repr__(self) -> str:\r\n-        return f\"r{self.number}\"\r\n-\r\n-class Literal(object):\r\n-    def __init__(self, value:int) -> None:\r\n-        self.value = value\r\n-    def __repr__(self) -> str:\r\n-        return str(self.value)\r\n-\r\n-class Token(object):\r\n-    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n-        self.name = name\r\n-        self.order = order\r\n-    def __repr__(self) -> str:\r\n-        if self.order:\r\n-            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n-        return self.name\r\n-\r\n-def lexer(Source:str) -> list[list[str]]:\r\n-    Tokens:list[list[str]] = []\r\n-    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n-    return Tokens\r\n-\r\n-def args(arg:list[str]) -> list[Literal | Register]:\r\n-    a:list[Literal | Register] = []\r\n-    for i in arg:\r\n-        if i[0] == \"r\" and i[1::].isdecimal():\r\n-            a.append(Register(int(i[1::])))\r\n-        elif i.isdecimal():\r\n-            a.append(Literal(int(i)))\r\n-        elif i[0] == \";\":\r\n-            break\r\n-        else:\r\n-            print(\"error\")\r\n-    return a\r\n-\r\n-def parse(Source:list[list[str]]) -> list[Token]:\r\n-    Tokens:list[Token] = []\r\n-    for i in Source:\r\n-        print(i)\r\n-        if i == []:\r\n-            return []\r\n-        if i[0][0] == \";\":\r\n-            continue\r\n-        tok:Token = Token(i[0], args(i[1::]))\r\n-        Tokens.append(tok)\r\n-    return Tokens\r\n-\r\n-def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n-    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n-    if types is not None and type(tok) is not types:\r\n-        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n-    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n-    if isinstance(tok, Literal):\r\n-        # 2桁の16進（ゼロパディング）\r\n-        return format(tok.value & 0xff, '02x')\r\n-    if isinstance(tok, Register):\r\n-        return format(tok.number & 0xf, 'x')\r\n-    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n-\r\n-def conversion(Tokens:list[Token]):\r\n-    out:str = \"\"\r\n-    for i in Tokens:\r\n-        print(i)\r\n-        match (i.name.upper()):\r\n-            case \"ADD\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"0\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"SUB\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"1\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"ADDI\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n-                    # OK\r\n-                    out += \"2\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Literal)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"SUBI\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n-                    # OK\r\n-                    out += \"3\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Literal)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"NAND\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"4\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"SHIFT\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n-                    # OK\r\n-                    out += \"5\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += hex(i.order[2].value & 0xf)[2::]\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"STORE\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"6\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"LOAD\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"7\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"BRANCH\":\r\n-                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"8\"\r\n-                    out += hex(i.order[0].value & 0xf)[2::]\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"TIMER\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"9\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"RET\":\r\n-                # OK\r\n-                out += \"A\"\r\n-                out += \"000\"\r\n-            case \"HALT\":\r\n-                # OK\r\n-                out += \"B\"\r\n-                out += \"000\"\r\n-            case _:\r\n-                print(\"Error!\")\r\n-                return \"\"\r\n-    return out\r\n-\r\n-\"\"\"\r\n-ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n-SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n-ADDI r1 , n2          ; r1 = r2 + nn\r\n-SUBI r1 , n2          ; r1 = r2 - nn\r\n-NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n-SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n-STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n-LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n-BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n-TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n-RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n-HALT                  ; 停止\r\n-\"\"\"\r\n-\r\n-if __name__ == \"__main__\":\r\n-    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n-    lexed = lexer(source)\r\n-    parsed = parse(lexed)\r\n-    res = conversion(parsed)\r\n-    with open(\"out.bin\", \"w\") as f:\r\n-        f.write(res)\n-from __future__ import annotations\r\n-import ykcc.src.util as util\r\n-\r\n-class Register(object):\r\n-    def __init__(self, number:int) -> None:\r\n-        self.number = number\r\n-    def __repr__(self) -> str:\r\n-        return f\"r{self.number}\"\r\n-\r\n-class Literal(object):\r\n-    def __init__(self, value:int) -> None:\r\n-        self.value = value\r\n-    def __repr__(self) -> str:\r\n-        return str(self.value)\r\n-\r\n-class Token(object):\r\n-    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n-        self.name = name\r\n-        self.order = order\r\n-    def __repr__(self) -> str:\r\n-        if self.order:\r\n-            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n-        return self.name\r\n-\r\n-def lexer(Source:str) -> list[list[str]]:\r\n-    Tokens:list[list[str]] = []\r\n-    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n-    return Tokens\r\n-\r\n-def args(arg:list[str]) -> list[Literal | Register]:\r\n-    a:list[Literal | Register] = []\r\n-    for i in arg:\r\n-        if i[0] == \"r\" and i[1::].isdecimal():\r\n-            a.append(Register(int(i[1::])))\r\n-        elif i.isdecimal():\r\n-            a.append(Literal(int(i)))\r\n-        elif i[0] == \";\":\r\n-            break\r\n-        else:\r\n-            print(\"error\")\r\n-    return a\r\n-\r\n-def parse(Source:list[list[str]]) -> list[Token]:\r\n-    Tokens:list[Token] = []\r\n-    for i in Source:\r\n-        print(i)\r\n-        if i == []:\r\n-            return []\r\n-        if i[0][0] == \";\":\r\n-            continue\r\n-        tok:Token = Token(i[0], args(i[1::]))\r\n-        Tokens.append(tok)\r\n-    return Tokens\r\n-\r\n-def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n-    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n-    if types is not None and type(tok) is not types:\r\n-        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n-    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n-    if isinstance(tok, Literal):\r\n-        # 2桁の16進（ゼロパディング）\r\n-        return format(tok.value & 0xff, '02x')\r\n-    if isinstance(tok, Register):\r\n-        return format(tok.number & 0xf, 'x')\r\n-    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n-\r\n-def conversion(Tokens:list[Token]):\r\n-    out:str = \"\"\r\n-    for i in Tokens:\r\n-        print(i)\r\n-        match (i.name.upper()):\r\n-            case \"ADD\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"0\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"SUB\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"1\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"ADDI\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n-                    # OK\r\n-                    out += \"2\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Literal)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"SUBI\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n-                    # OK\r\n-                    out += \"3\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Literal)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"NAND\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"4\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"SHIFT\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n-                    # OK\r\n-                    out += \"5\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += hex(i.order[2].value & 0xf)[2::]\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"STORE\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"6\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"LOAD\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"7\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"BRANCH\":\r\n-                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"8\"\r\n-                    out += hex(i.order[0].value & 0xf)[2::]\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"TIMER\":\r\n-                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n-                    # OK\r\n-                    out += \"9\"\r\n-                    out += argsLoad(i.order[0], Register)\r\n-                    out += argsLoad(i.order[1], Register)\r\n-                    out += argsLoad(i.order[2], Register)\r\n-                else:\r\n-                    print(\"Error\")\r\n-                    return \"\"\r\n-            case \"RET\":\r\n-                # OK\r\n-                out += \"A\"\r\n-                out += \"000\"\r\n-            case \"HALT\":\r\n-                # OK\r\n-                out += \"B\"\r\n-                out += \"000\"\r\n-            case _:\r\n-                print(\"Error!\")\r\n-                return \"\"\r\n-    return out\r\n-\r\n-\"\"\"\r\n-ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n-SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n-ADDI r1 , n2          ; r1 = r2 + nn\r\n-SUBI r1 , n2          ; r1 = r2 - nn\r\n-NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n-SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n-STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n-LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n-BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n-TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n-RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n-HALT                  ; 停止\r\n-\"\"\"\r\n-\r\n-if __name__ == \"__main__\":\r\n-    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n-    lexed = lexer(source)\r\n-    parsed = parse(lexed)\r\n-    res = conversion(parsed)\r\n-    with open(\"out.bin\", \"w\") as f:\r\n-        f.write(res)\n-from __future__ import annotations\r\n import src.util as util\r\n \r\n class Register(object):\r\n     def __init__(self, number:int) -> None:\r\n"
                },
                {
                    "date": 1760305043674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,204 @@\n+from __future__ import annotations\r\n+import ..util as util\r\n+\r\n+class Register(object):\r\n+    def __init__(self, number:int) -> None:\r\n+        self.number = number\r\n+    def __repr__(self) -> str:\r\n+        return f\"r{self.number}\"\r\n+\r\n+class Literal(object):\r\n+    def __init__(self, value:int) -> None:\r\n+        self.value = value\r\n+    def __repr__(self) -> str:\r\n+        return str(self.value)\r\n+\r\n+class Token(object):\r\n+    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n+        self.name = name\r\n+        self.order = order\r\n+    def __repr__(self) -> str:\r\n+        if self.order:\r\n+            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n+        return self.name\r\n+\r\n+def lexer(Source:str) -> list[list[str]]:\r\n+    Tokens:list[list[str]] = []\r\n+    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n+    return Tokens\r\n+\r\n+def args(arg:list[str]) -> list[Literal | Register]:\r\n+    a:list[Literal | Register] = []\r\n+    for i in arg:\r\n+        if i[0] == \"r\" and i[1::].isdecimal():\r\n+            a.append(Register(int(i[1::])))\r\n+        elif i.isdecimal():\r\n+            a.append(Literal(int(i)))\r\n+        elif i[0] == \";\":\r\n+            break\r\n+        else:\r\n+            print(\"error\")\r\n+    return a\r\n+\r\n+def parse(Source:list[list[str]]) -> list[Token]:\r\n+    Tokens:list[Token] = []\r\n+    for i in Source:\r\n+        print(i)\r\n+        if i == []:\r\n+            return []\r\n+        if i[0][0] == \";\":\r\n+            continue\r\n+        tok:Token = Token(i[0], args(i[1::]))\r\n+        Tokens.append(tok)\r\n+    return Tokens\r\n+\r\n+def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n+    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n+    if types is not None and type(tok) is not types:\r\n+        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n+    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n+    if isinstance(tok, Literal):\r\n+        # 2桁の16進（ゼロパディング）\r\n+        return format(tok.value & 0xff, '02x')\r\n+    if isinstance(tok, Register):\r\n+        return format(tok.number & 0xf, 'x')\r\n+    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n+\r\n+def conversion(Tokens:list[Token]):\r\n+    out:str = \"\"\r\n+    for i in Tokens:\r\n+        print(i)\r\n+        match (i.name.upper()):\r\n+            case \"ADD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"0\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUB\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"1\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"ADDI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"2\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUBI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"3\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"NAND\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"4\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SHIFT\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n+                    # OK\r\n+                    out += \"5\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += hex(i.order[2].value & 0xf)[2::]\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"STORE\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"6\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"LOAD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"7\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"BRANCH\":\r\n+                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"8\"\r\n+                    out += hex(i.order[0].value & 0xf)[2::]\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"TIMER\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"9\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"RET\":\r\n+                # OK\r\n+                out += \"A\"\r\n+                out += \"000\"\r\n+            case \"HALT\":\r\n+                # OK\r\n+                out += \"B\"\r\n+                out += \"000\"\r\n+            case _:\r\n+                print(\"Error!\")\r\n+                return \"\"\r\n+    return out\r\n+\r\n+\"\"\"\r\n+ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n+SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n+ADDI r1 , n2          ; r1 = r2 + nn\r\n+SUBI r1 , n2          ; r1 = r2 - nn\r\n+NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n+SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n+STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n+LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n+BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n+TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n+RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n+HALT                  ; 停止\r\n+\"\"\"\r\n+\r\n+if __name__ == \"__main__\":\r\n+    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n+    lexed = lexer(source)\r\n+    parsed = parse(lexed)\r\n+    res = conversion(parsed)\r\n+    with open(\"out.bin\", \"w\") as f:\r\n+        f.write(res)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760305054112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n from __future__ import annotations\r\n-import .util as util\r\n+import ....util as util\r\n \r\n class Register(object):\r\n     def __init__(self, number:int) -> None:\r\n         self.number = number\r\n"
                },
                {
                    "date": 1760305060366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,204 @@\n+from __future__ import annotations\r\n+import ..src.util as util\r\n+\r\n+class Register(object):\r\n+    def __init__(self, number:int) -> None:\r\n+        self.number = number\r\n+    def __repr__(self) -> str:\r\n+        return f\"r{self.number}\"\r\n+\r\n+class Literal(object):\r\n+    def __init__(self, value:int) -> None:\r\n+        self.value = value\r\n+    def __repr__(self) -> str:\r\n+        return str(self.value)\r\n+\r\n+class Token(object):\r\n+    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n+        self.name = name\r\n+        self.order = order\r\n+    def __repr__(self) -> str:\r\n+        if self.order:\r\n+            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n+        return self.name\r\n+\r\n+def lexer(Source:str) -> list[list[str]]:\r\n+    Tokens:list[list[str]] = []\r\n+    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n+    return Tokens\r\n+\r\n+def args(arg:list[str]) -> list[Literal | Register]:\r\n+    a:list[Literal | Register] = []\r\n+    for i in arg:\r\n+        if i[0] == \"r\" and i[1::].isdecimal():\r\n+            a.append(Register(int(i[1::])))\r\n+        elif i.isdecimal():\r\n+            a.append(Literal(int(i)))\r\n+        elif i[0] == \";\":\r\n+            break\r\n+        else:\r\n+            print(\"error\")\r\n+    return a\r\n+\r\n+def parse(Source:list[list[str]]) -> list[Token]:\r\n+    Tokens:list[Token] = []\r\n+    for i in Source:\r\n+        print(i)\r\n+        if i == []:\r\n+            return []\r\n+        if i[0][0] == \";\":\r\n+            continue\r\n+        tok:Token = Token(i[0], args(i[1::]))\r\n+        Tokens.append(tok)\r\n+    return Tokens\r\n+\r\n+def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n+    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n+    if types is not None and type(tok) is not types:\r\n+        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n+    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n+    if isinstance(tok, Literal):\r\n+        # 2桁の16進（ゼロパディング）\r\n+        return format(tok.value & 0xff, '02x')\r\n+    if isinstance(tok, Register):\r\n+        return format(tok.number & 0xf, 'x')\r\n+    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n+\r\n+def conversion(Tokens:list[Token]):\r\n+    out:str = \"\"\r\n+    for i in Tokens:\r\n+        print(i)\r\n+        match (i.name.upper()):\r\n+            case \"ADD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"0\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUB\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"1\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"ADDI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"2\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SUBI\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n+                    # OK\r\n+                    out += \"3\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Literal)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"NAND\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"4\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"SHIFT\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n+                    # OK\r\n+                    out += \"5\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += hex(i.order[2].value & 0xf)[2::]\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"STORE\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"6\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"LOAD\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"7\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"BRANCH\":\r\n+                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"8\"\r\n+                    out += hex(i.order[0].value & 0xf)[2::]\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"TIMER\":\r\n+                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n+                    # OK\r\n+                    out += \"9\"\r\n+                    out += argsLoad(i.order[0], Register)\r\n+                    out += argsLoad(i.order[1], Register)\r\n+                    out += argsLoad(i.order[2], Register)\r\n+                else:\r\n+                    print(\"Error\")\r\n+                    return \"\"\r\n+            case \"RET\":\r\n+                # OK\r\n+                out += \"A\"\r\n+                out += \"000\"\r\n+            case \"HALT\":\r\n+                # OK\r\n+                out += \"B\"\r\n+                out += \"000\"\r\n+            case _:\r\n+                print(\"Error!\")\r\n+                return \"\"\r\n+    return out\r\n+\r\n+\"\"\"\r\n+ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n+SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n+ADDI r1 , n2          ; r1 = r2 + nn\r\n+SUBI r1 , n2          ; r1 = r2 - nn\r\n+NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n+SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n+STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n+LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n+BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n+TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n+RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n+HALT                  ; 停止\r\n+\"\"\"\r\n+\r\n+if __name__ == \"__main__\":\r\n+    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n+    lexed = lexer(source)\r\n+    parsed = parse(lexed)\r\n+    res = conversion(parsed)\r\n+    with open(\"out.bin\", \"w\") as f:\r\n+        f.write(res)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1760304849647,
            "name": "Commit-0",
            "content": "from __future__ import annotations\r\nimport src.util as util\r\n\r\nclass Register(object):\r\n    def __init__(self, number:int) -> None:\r\n        self.number = number\r\n    def __repr__(self) -> str:\r\n        return f\"r{self.number}\"\r\n\r\nclass Literal(object):\r\n    def __init__(self, value:int) -> None:\r\n        self.value = value\r\n    def __repr__(self) -> str:\r\n        return str(self.value)\r\n\r\nclass Token(object):\r\n    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n        self.name = name\r\n        self.order = order\r\n    def __repr__(self) -> str:\r\n        if self.order:\r\n            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n        return self.name\r\n\r\ndef lexer(Source:str) -> list[list[str]]:\r\n    Tokens:list[list[str]] = []\r\n    [Tokens.append([k for k in sum([j.split(\" \") for j in i.split(\",\")], []) if k != '']) for i in Source.split(\"\\n\")]\r\n    return Tokens\r\n\r\ndef args(arg:list[str]) -> list[Literal | Register]:\r\n    a:list[Literal | Register] = []\r\n    for i in arg:\r\n        if i[0] == \"r\" and i[1::].isdecimal():\r\n            a.append(Register(int(i[1::])))\r\n        elif i.isdecimal():\r\n            a.append(Literal(int(i)))\r\n        elif i[0] == \";\":\r\n            break\r\n        else:\r\n            print(\"error\")\r\n    return a\r\n\r\ndef parse(Source:list[list[str]]) -> list[Token]:\r\n    Tokens:list[Token] = []\r\n    for i in Source:\r\n        print(i)\r\n        if i == []:\r\n            return []\r\n        if i[0][0] == \";\":\r\n            continue\r\n        tok:Token = Token(i[0], args(i[1::]))\r\n        Tokens.append(tok)\r\n    return Tokens\r\n\r\ndef argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n    if types is not None and type(tok) is not types:\r\n        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n    if isinstance(tok, Literal):\r\n        # 2桁の16進（ゼロパディング）\r\n        return format(tok.value & 0xff, '02x')\r\n    if isinstance(tok, Register):\r\n        return format(tok.number & 0xf, 'x')\r\n    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n\r\ndef conversion(Tokens:list[Token]):\r\n    out:str = \"\"\r\n    for i in Tokens:\r\n        print(i)\r\n        match (i.name.upper()):\r\n            case \"ADD\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"0\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"SUB\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"1\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"ADDI\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n                    # OK\r\n                    out += \"2\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Literal)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"SUBI\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n                    # OK\r\n                    out += \"3\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Literal)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"NAND\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"4\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"SHIFT\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n                    # OK\r\n                    out += \"5\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += hex(i.order[2].value & 0xf)[2::]\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"STORE\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"6\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"LOAD\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"7\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"BRANCH\":\r\n                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"8\"\r\n                    out += hex(i.order[0].value & 0xf)[2::]\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"TIMER\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"9\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    print(\"Error\")\r\n                    return \"\"\r\n            case \"RET\":\r\n                # OK\r\n                out += \"A\"\r\n                out += \"000\"\r\n            case \"HALT\":\r\n                # OK\r\n                out += \"B\"\r\n                out += \"000\"\r\n            case _:\r\n                print(\"Error!\")\r\n                return \"\"\r\n    return out\r\n\r\n\"\"\"\r\nADD r1 , r2 , r3      ; r1 = r2 + r3\r\nSUB r1 , r2 , r3      ; r1 = r2 - r3\r\nADDI r1 , n2          ; r1 = r2 + nn\r\nSUBI r1 , n2          ; r1 = r2 - nn\r\nNAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\nSHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\nSTORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\nLOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\nBRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\nTIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\nRET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\nHALT                  ; 停止\r\n\"\"\"\r\n\r\nif __name__ == \"__main__\":\r\n    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n    lexed = lexer(source)\r\n    parsed = parse(lexed)\r\n    res = conversion(parsed)\r\n    with open(\"out.bin\", \"w\") as f:\r\n        f.write(res)"
        }
    ]
}