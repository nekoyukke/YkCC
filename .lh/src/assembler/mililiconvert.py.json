{
    "sourceFile": "src/assembler/mililiconvert.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1761641405222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761641415295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -220,26 +220,11 @@\n RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n HALT                  ; 停止\r\n \"\"\"\r\n \r\n-\"\"\"\r\n-ADD r1 , r2 , r3      ; r1 = r2 + r3\r\n-SUB r1 , r2 , r3      ; r1 = r2 - r3\r\n-ADDI r1 , n2          ; r1 = r2 + nn\r\n-SUBI r1 , n2          ; r1 = r2 - nn\r\n-NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\n-SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\n-STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\n-LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\n-BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\n-TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\n-RET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\n-HALT                  ; 停止\r\n-\"\"\"\r\n-\r\n if __name__ == \"__main__\":\r\n     source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n     lexed = lexer(source)\r\n     parsed = parse(lexed)\r\n-    res = conversion(parsed)\r\n+    res = conversion(parsed,0)\r\n     with open(\"out.bin\", \"w\") as f:\r\n         f.write(res)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1761641405221,
            "name": "Commit-0",
            "content": "\r\nfrom __future__ import annotations\r\nimport sys\r\nfrom pathlib import Path\r\n\r\nrepo_root = Path(__file__).resolve().parents[2]\r\nif str(repo_root) not in sys.path:\r\n    sys.path.insert(0, str(repo_root))\r\nimport src.util as util\r\n\r\nclass Register(object):\r\n    def __init__(self, number:int) -> None:\r\n        self.number = number\r\n    def __repr__(self) -> str:\r\n        return f\"r{self.number}\"\r\n\r\nclass Literal(object):\r\n    def __init__(self, value:int) -> None:\r\n        self.value = value\r\n    def __repr__(self) -> str:\r\n        return str(self.value)\r\n\r\nclass Token(object):\r\n    def __init__(self, name:str, order:list[Literal | Register]) -> None:\r\n        self.name = name\r\n        self.order = order\r\n    def __repr__(self) -> str:\r\n        if self.order:\r\n            return f\"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }\"\r\n        return self.name\r\n\r\ndef lexer(Source:str) -> list[list[str]]:\r\n    Tokens: list[list[str]] = []\r\n    # Use splitlines() to handle CRLF/LF transparently and remove newline chars\r\n    for line in Source.splitlines():\r\n        # Remove comments starting with ';'\r\n        if ';' in line:\r\n            line = line.split(';', 1)[0]\r\n        # Skip empty/whitespace-only lines\r\n        if not line.strip():\r\n            continue\r\n        parts: list[str] = [p.strip() for p in line.split(',') if p.strip()]\r\n        toks: list[str] = []\r\n        for p in parts:\r\n            toks.extend([t for t in p.split() if t != ''])\r\n        Tokens.append(toks)\r\n    return Tokens\r\n\r\ndef args(arg:list[str]) -> list[Literal | Register]:\r\n    a:list[Literal | Register] = []\r\n    for i in arg:\r\n        token = i.strip()\r\n        if not token:\r\n            continue\r\n        if token.startswith('r') and token[1:].isdecimal():\r\n            a.append(Register(int(token[1:])))\r\n        elif token.isdecimal():\r\n            a.append(Literal(int(token)))\r\n        elif token.startswith(';'):\r\n            break\r\n        else:\r\n            # Unknown token; keep behavior but include token for debugging\r\n            print(f\"error: unexpected token '{token}'\")\r\n    return a\r\n\r\ndef parse(Source:list[list[str]]) -> list[Token]:\r\n    Tokens:list[Token] = []\r\n    for i in Source:\r\n        print(i)\r\n        if i == []:\r\n            continue\r\n        if i[0].startswith(';'):\r\n            continue\r\n        tok:Token = Token(i[0], args(i[1:]))\r\n        Tokens.append(tok)\r\n    return Tokens\r\n\r\ndef argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):\r\n    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す\r\n    if types is not None and type(tok) is not types:\r\n        raise TypeError(f\"argsLoad expected {types.__name__}, got {type(tok).__name__}\")\r\n    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す\r\n    if isinstance(tok, Literal):\r\n        # 2桁の16進（ゼロパディング）\r\n        return format(tok.value & 0xff, '02x')\r\n    if isinstance(tok, Register):\r\n        return format(tok.number & 0xf, 'x')\r\n    raise TypeError(f\"Unsupported token type: {type(tok).__name__}\")\r\n\r\ndef conversion(Tokens:list[Token], mode:int):\r\n    out:str = \"\"\r\n    mode = int(mode)\r\n    if mode < 0 or mode >= 3:\r\n        label = \"\"\r\n    else:\r\n        label = [\"\", \",\", \"\\\\n\"][mode]\r\n    for i in Tokens:\r\n        print(i)\r\n        match (i.name.upper()):\r\n            case \"ADD\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"0\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"SUB\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"1\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"ADDI\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n                    # OK\r\n                    out += \"2\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Literal)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"SUBI\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Literal:\r\n                    # OK\r\n                    out += \"3\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Literal)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"NAND\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"4\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"SHIFT\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:\r\n                    # OK\r\n                    out += \"5\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += hex(i.order[2].value & 0xf)[2::]\r\n                else:\r\n                    return \"Error!\"\r\n            case \"STORE\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"6\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"LOAD\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"7\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"BRANCH\":\r\n                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"8\"\r\n                    out += hex(i.order[0].value & 0xf)[2::]\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                    print(\"If input reg2 is odd, this may result in a poor implementation.\")\r\n                else:\r\n                    return \"Error!\"\r\n            case \"TIMER\":\r\n                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:\r\n                    # OK\r\n                    out += \"9\"\r\n                    out += argsLoad(i.order[0], Register)\r\n                    out += argsLoad(i.order[1], Register)\r\n                    out += argsLoad(i.order[2], Register)\r\n                else:\r\n                    return \"Error!\"\r\n            case \"RET\":\r\n                # OK\r\n                out += \"A\"\r\n                out += \"000\"\r\n            case \"PC\":\r\n                out += \"A1\"\r\n                out += argsLoad(i.order[0], Register)\r\n                out += argsLoad(i.order[1], Register)\r\n            case \"RNG\":\r\n                out += \"A20\"\r\n                out += argsLoad(i.order[0], Register)\r\n            case \"HALT\":\r\n                # OK\r\n                out += \"A\"\r\n                out += \"F00\"\r\n            case _:\r\n                return \"Error!\"\r\n        out += label\r\n    return out\r\n\r\n\"\"\"\r\nADD r1 , r2 , r3      ; r1 = r2 + r3\r\nSUB r1 , r2 , r3      ; r1 = r2 - r3\r\nADDI r1 , n2          ; r1 = r2 + nn\r\nSUBI r1 , n2          ; r1 = r2 - nn\r\nNAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\nSHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\nSTORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\nLOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\nBRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\nTIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\nRET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\nHALT                  ; 停止\r\n\"\"\"\r\n\r\n\"\"\"\r\nADD r1 , r2 , r3      ; r1 = r2 + r3\r\nSUB r1 , r2 , r3      ; r1 = r2 - r3\r\nADDI r1 , n2          ; r1 = r2 + nn\r\nSUBI r1 , n2          ; r1 = r2 - nn\r\nNAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )\r\nSHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))\r\nSTORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1\r\nLOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)\r\nBRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ\r\nTIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ\r\nRET                   ; サブルーチンを終了しサブルーチン実行前に戻る\r\nHALT                  ; 停止\r\n\"\"\"\r\n\r\nif __name__ == \"__main__\":\r\n    source = util.read_a_file(\"ADDI r1,1\\nSUBI r1,1\")\r\n    lexed = lexer(source)\r\n    parsed = parse(lexed)\r\n    res = conversion(parsed)\r\n    with open(\"out.bin\", \"w\") as f:\r\n        f.write(res)"
        }
    ]
}