{
    "sourceFile": "src/conpiler/BASIC/parse.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1761387519053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761387528207,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,9 @@\n     raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n \r\n def parse(tokens:list[Token], source:str):\r\n     pos = 0\r\n-    llabeldict:dict[str,list[int]] = {} # \r\n-    glabeldict:dict[str,list[int]] = {}\r\n+    labeldict:dict[str,list[int]] = {} # \r\n     llabelpos = 0\r\n     glabelpos = 0\r\n     Scope:list[str] = [\"Global\"]\r\n \r\n"
                },
                {
                    "date": 1761387547033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n \r\n def parse(tokens:list[Token], source:str):\r\n     pos = 0\r\n-    labeldict:dict[str,list[int]] = {} # \r\n+    labeldict:dict[str,list[int]] = {} # name : now number, \r\n     llabelpos = 0\r\n     glabelpos = 0\r\n     Scope:list[str] = [\"Global\"]\r\n \r\n"
                },
                {
                    "date": 1761387558864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,103 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str):\r\n+    pos = 0\r\n+    labeldict:dict[str,list[int]] = {} # name : now number, \r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+    def comp(name:str) -> tuple[str, int,]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        # 数字\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Comp-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = \"\r\n+\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761387614145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n \r\n def parse(tokens:list[Token], source:str):\r\n     pos = 0\r\n-    labeldict:dict[str,list[int]] = {} # name : now number, \r\n+    labeldict:dict[str,list[int]] = {} # name : now number, mode\r\n     llabelpos = 0\r\n     glabelpos = 0\r\n     Scope:list[str] = [\"Global\"]\r\n \r\n"
                }
            ],
            "date": 1761387519053,
            "name": "Commit-0",
            "content": "\"\"\"\r\nIR設計を見直したためもう一度作成する\r\n\r\n\"\"\"\r\nfrom __future__ import annotations\r\nfrom array import array\r\nimport sys\r\nfrom lexer import Token\r\nfrom pathlib import Path\r\nrepo_root = Path(__file__).resolve().parents[2]\r\nif str(repo_root) not in sys.path:\r\n    sys.path.insert(0, str(repo_root))\r\nimport src.util as util\r\n\r\ndef CallError(tok:Token, message:str, name:str, source:str):\r\n    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n\r\ndef parse(tokens:list[Token], source:str):\r\n    pos = 0\r\n    llabeldict:dict[str,list[int]] = {} # \r\n    glabeldict:dict[str,list[int]] = {}\r\n    llabelpos = 0\r\n    glabelpos = 0\r\n    Scope:list[str] = [\"Global\"]\r\n\r\n    def usepos() -> int:\r\n        nonlocal llabelpos, glabelpos\r\n        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n            glabelpos += 1\r\n            return glabelpos\r\n        llabelpos += 1\r\n        return llabelpos\r\n    \r\n    def isglobal() -> bool:\r\n        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n    \r\n    def ad(name:str):\r\n        nonlocal pos\r\n        pos += 1\r\n        if len(tokens) <= pos:\r\n            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n\r\n    def cu():\r\n        return tokens[pos]\r\n    \r\n    def ex(tt:str, message:str, name:str):\r\n        if tt != cu().type:\r\n            CallError(cu(), message, name, source)\r\n        res = cu()\r\n        ad(name)\r\n        return res\r\n    \r\n    def stmt() -> str:\r\n        assembly = \"\"\r\n        while cu().type != \"EOF\":\r\n            exp = expr()\r\n            assembly += exp\r\n        return assembly\r\n    \r\n    def expr() -> str:\r\n        # YkIR\r\n        res = \"\"\r\n        # 行を分析\r\n        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n        if cu().type == \"LINE_NUM\":\r\n            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n        else:\r\n            # show what we actually have for easier debugging\r\n            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n            raise\r\n        if (cu().type != \"KEYWORD\"):\r\n            return \"\"\r\n        res += f\"; LINE{linetok.value}\\n\"\r\n        res += f\"LINE{linetok.value}:\\n\"\r\n        match (cu().value):\r\n            case \"LET\":\r\n                ad(\"Let\")\r\n                # letを分析\r\n                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n                # ASS\r\n                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n                # numbers\r\n                \r\n            case _:\r\n                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n    def comp(name:str) -> tuple[str, int,]:\r\n        addr:int = usepos()\r\n        isglobal_ = isglobal()\r\n        cur = cu()\r\n        # 数字\r\n        if cur.type == \"NUMBER\":\r\n            if isglobal_:\r\n                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n        elif cur.type == \"IDENT\":\r\n            if isglobal_:\r\n                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Comp-{name}\",source)\r\n                raise\r\n            return f\"%{addr} = \"\r\n\r\n    return stmt()"
        }
    ]
}