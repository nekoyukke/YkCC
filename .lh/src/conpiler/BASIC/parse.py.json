{
    "sourceFile": "src/conpiler/BASIC/parse.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1762274443752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762274449198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,377 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+\r\n+# When this module is executed directly the import `src.util` may fail because\r\n+# the parent of the `src` directory isn't on sys.path. Find the project root\r\n+# (the directory that contains the `src` folder) and add it to sys.path.\r\n+_p = Path(__file__).resolve()\r\n+repo_root = None\r\n+for a in ([_p] + list(_p.parents)):\r\n+    if (a / 'src').is_dir():\r\n+        repo_root = a\r\n+        break\r\n+if repo_root is None:\r\n+    # fallback: two levels up (best-effort)\r\n+    repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,int]] = {\"Global\":{}} # Scope:{name : addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+    nowtab:int = 0\r\n+    Function:list[str] = []\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def addlabel(name:Token, namefunc:str) -> None:\r\n+        if name.value in labeldict[Scope[-1]]:\r\n+            CallError(name, f\"variable {name.value} is duplicated.\", namefunc, source)\r\n+            raise\r\n+        labeldict[Scope[-1]][name.value] = 0\r\n+    \r\n+    def uselabel(name:Token, namefunc:str) -> None:\r\n+        if not name.value in labeldict[Scope[-1]]:\r\n+            CallError(name, f\"Variable {name.value} does not exist\", namefunc, source)\r\n+            raise\r\n+        labeldict[Scope[-1]][name.value] += 1\r\n+\r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,int]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def Addlabel(name:str, tok:Token, call:str):\r\n+        nonlocal Scope, Function\r\n+        if name in labeldict:\r\n+            CallError(tok, \"Duplicate function declaration name.\", call, source)\r\n+            raise\r\n+        labeldict[name] = {}\r\n+        Scope += [name]\r\n+        Function += [name]\r\n+        return\r\n+\r\n+    def delllabel(name:str, call:str):\r\n+        if name not in labeldict:\r\n+            CallError(cu(), \"Function declaration name not found.\", call, source)\r\n+            raise\r\n+        labeldict.pop(name)\r\n+        Scope.pop(-1)\r\n+        return\r\n+            \r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        nonlocal nowtab\r\n+        res = \"\"\r\n+        match (cu().type):\r\n+            case \"IDENT\":\r\n+                # 関数 or 代入\r\n+                # function or ASSGIN\r\n+                Ident:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if cu().type == \"ASS\":\r\n+                    # ASSGIN\r\n+                    uselabel(Ident, \"Ident ASS\")\r\n+                    ex(\"ASS\", \"??\", \"Ident ASS\")\r\n+                    # com sep\r\n+                    com = comp(\"Let\")\r\n+                    res += com[0] + \"\\n\"\r\n+                    if isglobal():\r\n+                        res += \"    \"*nowtab + f\"void:store {sz}:@{com[1]}, {sz}*:@{Ident.value}\\n\"\r\n+                    else:\r\n+                        res += \"    \"*nowtab + f\"void:store {sz}:%{com[1]}, {sz}*:%{Ident.value}\\n\"\r\n+                    ex(\"NEWLINE\", \"Error\", \"let\")\r\n+                    return res\r\n+                pass\r\n+            case _:\r\n+                pass\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                Ident:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                ex(\"ASS\", \"The = operator is unknown\", \"Let\")\r\n+                # numbers\r\n+                com = comp(\"Let\")\r\n+                res += com[0] + \"\\n\"\r\n+                addlabel(Ident, \"Let\")\r\n+                if isglobal():\r\n+                    res += \"    \"*nowtab + f\"@{Ident.value} = {sz}*:global {sz}\\n\"\r\n+                    res += \"    \"*nowtab + f\"void:store {sz}:@{com[1]}, {sz}*:@{Ident.value}\\n\"\r\n+                else:\r\n+                    res += \"    \"*nowtab + f\"%{Ident.value} = {sz}*:alloca {sz}\\n\"\r\n+                    res += \"    \"*nowtab + f\"void:store {sz}:%{com[1]}, {sz}*:%{Ident.value}\\n\"\r\n+                ex(\"NEWLINE\", \"Error\", \"let\")\r\n+                print(labeldict[Scope[-1]])\r\n+                return res\r\n+            case \"FUNC\":\r\n+                ad(\"Func\")\r\n+                # Funcを分析\r\n+                # analyze func\r\n+                Ident:Token = ex(\"IDENT\", \"No function identifier\", \"Func\")\r\n+                # Function Args\r\n+                ex(\"LPAREN\", \"The syntax for naming function arguments is not complete\", \"Func\")\r\n+                # name onlry\r\n+                Args:list[Token] = []\r\n+                while cu().type != \"RPAREN\":\r\n+                    tok:Token = ex(\"IDENT\", \"The function arguments have not been declared\", \"Func\")\r\n+                    Args.append(tok)\r\n+                    if cu().type == \"RPAREN\":\r\n+                        break\r\n+                    ex(\"COMMA\", \"The function arguments have not COMMA\", \"Func\")\r\n+                ex(\"RPAREN\", \"The syntax for naming function arguments is not complete\", \"Func\")\r\n+                Addlabel(Ident.value, Ident, \"Func\")\r\n+                res += \"    \"*nowtab + f\"define {sz}:@{Ident.value}({\"\".join([sz+ \":\" + i.value for i in Args])}) \"+ \"{\\n\"\r\n+                nowtab += 1\r\n+                res += \"    \"*nowtab + \"entry:\\n\"\r\n+                nowtab += 1\r\n+                for i in Args:\r\n+                    addlabel(i, \"Let\")\r\n+                ex(\"NEWLINE\", \"Error\", \"Func\")\r\n+                print(labeldict)\r\n+                print(Scope[-1])\r\n+                return res\r\n+            case \"RET\":\r\n+                ad(\"RET\")\r\n+                # Ret\r\n+                com = comp(\"RET\")\r\n+                res += com[0] + \"\\n\"\r\n+                res += \"    \"*nowtab + f\"void:ret {sz}:%{com[1]}\\n\"\r\n+                nowtab -= 2\r\n+                res += \"    \"*nowtab + \"}\\n\"\r\n+                ex(\"NEWLINE\", \"Error\", \"Func\")\r\n+                delllabel(Scope[-1], \"Ret\")\r\n+                return res\r\n+            case \"IF\":\r\n+                # if func\r\n+                ad(\"IF\")\r\n+                # \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return \"    \"*nowtab + f\"@{addr} = {sz}*:global {sz}:{cur.value}\\n\",addr\r\n+            return \"    \"*nowtab + f\"%{addr} = {cur.value}\\n\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            if cur.value in scope:\r\n+                return \"    \"*nowtab + f\"%{addr} = {sz}:load {sz}*:%{cur.value}\\n\",addr\r\n+            if cur.value in labeldict[\"Global\"]:\r\n+                return \"    \"*nowtab + f\"%{addr} = {sz}:load {sz}*:@{cur.value}\\n\",addr\r\n+            if cur.value in Function:\r\n+                ex(\"LPAREN\", \"The syntax for naming function arguments is not complete\", \"callFunc\")\r\n+                # anarlyz args\r\n+                Args:list[Token] = []\r\n+                while cu().type != \"RPAREN\":\r\n+                    tok:Token = ex(\"IDENT\", \"The function arguments have not been declared\", \"callFunc\")\r\n+                    Args.append(tok)\r\n+                    if cu().type == \"RPAREN\":\r\n+                        break\r\n+                    ex(\"COMMA\", \"The function arguments have not COMMA\", \"callFunc\")\r\n+                ex(\"RPAREN\", \"The syntax for naming function arguments is not complete\", \"callFunc\")\r\n+                res += \"    \"*nowtab + f\"%{addr} = {sz}:call @{cur.value}({\"\".join([sz+ \"*:%\" + i.value for i in Args])}) \"\r\n+                return res, addr\r\n+            CallError(cur, \"The identifier could not be found\", f\"Compute-{name}\",source)\r\n+            raise\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        com1 = comp(f\"Compute-{name}\")\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        print(com1)\r\n+                        while cu().type != \"RPAREN\":\r\n+                            com2 = comp(f\"Compute-{name}\")\r\n+                            res += com1[0] + \"\\n\"\r\n+                            res += com2[0] + \"\\n\"\r\n+                            if isglobal_:\r\n+                                res += \"    \"*nowtab + f\"@{addr} = {sz}:add {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n+                            else:\r\n+                                res += \"    \"*nowtab + f\"%{addr} = {sz}:add {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n+                            com1 = com2\r\n+                            if cu().type == \"RPAREN\":\r\n+                                break\r\n+                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                            addr = usepos()\r\n+                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n+                        return res, addr\r\n+                    case \"-\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        com1 = comp(f\"Compute-{name}\")\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        print(com1)\r\n+                        while cu().type != \"RPAREN\":\r\n+                            com2 = comp(f\"Compute-{name}\")\r\n+                            res += com1[0] + \"\\n\"\r\n+                            res += com2[0] + \"\\n\"\r\n+                            if isglobal_:\r\n+                                res += \"    \"*nowtab + f\"@{addr} = {sz}:sub {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n+                            else:\r\n+                                res += \"    \"*nowtab + f\"%{addr} = {sz}:sub {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n+                            com1 = com2\r\n+                            if cu().type == \"RPAREN\":\r\n+                                break\r\n+                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                            addr = usepos()\r\n+                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n+                        return res, addr\r\n+                    case \"*\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        com1 = comp(f\"Compute-{name}\")\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        print(com1)\r\n+                        while cu().type != \"RPAREN\":\r\n+                            com2 = comp(f\"Compute-{name}\")\r\n+                            res += com1[0] + \"\\n\"\r\n+                            res += com2[0] + \"\\n\"\r\n+                            if isglobal_:\r\n+                                res += \"    \"*nowtab + f\"@{addr} = {sz}:mul {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n+                            else:\r\n+                                res += \"    \"*nowtab + f\"%{addr} = {sz}:mul {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n+                            com1 = com2\r\n+                            if cu().type == \"RPAREN\":\r\n+                                break\r\n+                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                            addr = usepos()\r\n+                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n+                        return res, addr\r\n+                    case \"/\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        com1 = comp(f\"Compute-{name}\")\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        print(com1)\r\n+                        while cu().type != \"RPAREN\":\r\n+                            com2 = comp(f\"Compute-{name}\")\r\n+                            res += com1[0] + \"\\n\"\r\n+                            res += com2[0] + \"\\n\"\r\n+                            if isglobal_:\r\n+                                res += \"    \"*nowtab + f\"@{addr} = {sz}:divv {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n+                            else:\r\n+                                res += \"    \"*nowtab + f\"%{addr} = {sz}:divv {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n+                            com1 = com2\r\n+                            if cu().type == \"RPAREN\":\r\n+                                break\r\n+                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                            addr = usepos()\r\n+                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n+                        return res, addr\r\n+                    case \"%\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        com1 = comp(f\"Compute-{name}\")\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        print(com1)\r\n+                        while cu().type != \"RPAREN\":\r\n+                            com2 = comp(f\"Compute-{name}\")\r\n+                            res += com1[0] + \"\\n\"\r\n+                            res += com2[0] + \"\\n\"\r\n+                            if isglobal_:\r\n+                                res += \"    \"*nowtab + f\"@{addr} = {sz}:divv {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n+                            else:\r\n+                                res += \"    \"*nowtab + f\"%{addr} = {sz}:divv {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n+                            com1 = com2\r\n+                            if cu().type == \"RPAREN\":\r\n+                                break\r\n+                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                            addr = usepos()\r\n+                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n+                        return res, addr\r\n+                    case \"addr\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        com1 = comp(f\"Compute-{name}\")\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                        print(com1)\r\n+                        while cu().type != \"RPAREN\":\r\n+                            com2 = comp(f\"Compute-{name}\")\r\n+                            res += com1[0] + \"\\n\"\r\n+                            res += com2[0] + \"\\n\"\r\n+                            if isglobal_:\r\n+                                res += \"    \"*nowtab + f\"@{addr} = {sz}:gep {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n+                            else:\r\n+                                res += \"    \"*nowtab + f\"%{addr} = {sz}:gep {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n+                            com1 = com2\r\n+                            if cu().type == \"RPAREN\":\r\n+                                break\r\n+                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                            addr = usepos()\r\n+                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n+                        return res, addr\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            CallError(cur, \"unkwon\", f\"Compute-{name}\",source)\r\n+            raise\r\n+        CallError(cur, \"unkwon\", f\"Compute-{name}\",source)\r\n+        raise\r\n+    return stmt() + f\"\\n{sz}:call @main()\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762274567505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -197,9 +197,9 @@\n                 return res\r\n             case \"IF\":\r\n                 # if func\r\n                 ad(\"IF\")\r\n-                # \r\n+                # 比較\r\n             case _:\r\n                 CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                 raise\r\n \r\n"
                },
                {
                    "date": 1762274573412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,8 +198,9 @@\n             case \"IF\":\r\n                 # if func\r\n                 ad(\"IF\")\r\n                 # 比較\r\n+                \r\n             case _:\r\n                 CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                 raise\r\n \r\n"
                },
                {
                    "date": 1762274584092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n             case \"IF\":\r\n                 # if func\r\n                 ad(\"IF\")\r\n                 # 比較\r\n-                \r\n+                comp[]\r\n             case _:\r\n                 CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                 raise\r\n \r\n"
                },
                {
                    "date": 1762274604025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n             case \"IF\":\r\n                 # if func\r\n                 ad(\"IF\")\r\n                 # 比較\r\n-                comp\r\n+                comp()\r\n             case _:\r\n                 CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                 raise\r\n \r\n"
                },
                {
                    "date": 1762274609342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n             case \"IF\":\r\n                 # if func\r\n                 ad(\"IF\")\r\n                 # 比較\r\n-                comp()\r\n+                comp(\"IF\")\r\n             case _:\r\n                 CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                 raise\r\n \r\n"
                }
            ],
            "date": 1762274443752,
            "name": "Commit-0",
            "content": "\"\"\"\r\nIR設計を見直したためもう一度作成する\r\n\r\n\"\"\"\r\nfrom __future__ import annotations\r\nimport sys\r\nfrom lexer import Token\r\nfrom pathlib import Path\r\n\r\n# When this module is executed directly the import `src.util` may fail because\r\n# the parent of the `src` directory isn't on sys.path. Find the project root\r\n# (the directory that contains the `src` folder) and add it to sys.path.\r\n_p = Path(__file__).resolve()\r\nrepo_root = None\r\nfor a in ([_p] + list(_p.parents)):\r\n    if (a / 'src').is_dir():\r\n        repo_root = a\r\n        break\r\nif repo_root is None:\r\n    # fallback: two levels up (best-effort)\r\n    repo_root = Path(__file__).resolve().parents[2]\r\nif str(repo_root) not in sys.path:\r\n    sys.path.insert(0, str(repo_root))\r\nimport src.util as util\r\n\r\ndef CallError(tok:Token, message:str, name:str, source:str):\r\n    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n\r\ndef parse(tokens:list[Token], source:str, size:int):\r\n    \"\"\"\r\n    size -1 : anyi\r\n    size n : i n\r\n    \"\"\"\r\n    pos = 0\r\n    labeldict:dict[str,dict[str,int]] = {\"Global\":{}} # Scope:{name : addr}\r\n    llabelpos = 0\r\n    glabelpos = 0\r\n    Scope:list[str] = [\"Global\"]\r\n    nowtab:int = 0\r\n    Function:list[str] = []\r\n\r\n    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n\r\n    def usepos() -> int:\r\n        nonlocal llabelpos, glabelpos\r\n        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n            glabelpos += 1\r\n            return glabelpos\r\n        llabelpos += 1\r\n        return llabelpos\r\n    \r\n    def addlabel(name:Token, namefunc:str) -> None:\r\n        if name.value in labeldict[Scope[-1]]:\r\n            CallError(name, f\"variable {name.value} is duplicated.\", namefunc, source)\r\n            raise\r\n        labeldict[Scope[-1]][name.value] = 0\r\n    \r\n    def uselabel(name:Token, namefunc:str) -> None:\r\n        if not name.value in labeldict[Scope[-1]]:\r\n            CallError(name, f\"Variable {name.value} does not exist\", namefunc, source)\r\n            raise\r\n        labeldict[Scope[-1]][name.value] += 1\r\n\r\n    def isglobal() -> bool:\r\n        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n    \r\n    def Getlabel() -> dict[str,int]:\r\n        return labeldict[Scope[-1]]\r\n    \r\n    def Addlabel(name:str, tok:Token, call:str):\r\n        nonlocal Scope, Function\r\n        if name in labeldict:\r\n            CallError(tok, \"Duplicate function declaration name.\", call, source)\r\n            raise\r\n        labeldict[name] = {}\r\n        Scope += [name]\r\n        Function += [name]\r\n        return\r\n\r\n    def delllabel(name:str, call:str):\r\n        if name not in labeldict:\r\n            CallError(cu(), \"Function declaration name not found.\", call, source)\r\n            raise\r\n        labeldict.pop(name)\r\n        Scope.pop(-1)\r\n        return\r\n            \r\n    \r\n    def ad(name:str):\r\n        nonlocal pos\r\n        pos += 1\r\n        if len(tokens) <= pos:\r\n            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n\r\n    def cu():\r\n        return tokens[pos]\r\n    \r\n    def ex(tt:str, message:str, name:str):\r\n        if tt != cu().type:\r\n            CallError(cu(), message, name, source)\r\n        res = cu()\r\n        ad(name)\r\n        return res\r\n    \r\n    def stmt() -> str:\r\n        assembly = \"\"\r\n        while cu().type != \"EOF\":\r\n            exp = expr()\r\n            assembly += exp\r\n        return assembly\r\n    \r\n    def expr() -> str:\r\n        # YkIR\r\n        nonlocal nowtab\r\n        res = \"\"\r\n        match (cu().type):\r\n            case \"IDENT\":\r\n                # 関数 or 代入\r\n                # function or ASSGIN\r\n                Ident:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n                # ASS\r\n                if cu().type == \"ASS\":\r\n                    # ASSGIN\r\n                    uselabel(Ident, \"Ident ASS\")\r\n                    ex(\"ASS\", \"??\", \"Ident ASS\")\r\n                    # com sep\r\n                    com = comp(\"Let\")\r\n                    res += com[0] + \"\\n\"\r\n                    if isglobal():\r\n                        res += \"    \"*nowtab + f\"void:store {sz}:@{com[1]}, {sz}*:@{Ident.value}\\n\"\r\n                    else:\r\n                        res += \"    \"*nowtab + f\"void:store {sz}:%{com[1]}, {sz}*:%{Ident.value}\\n\"\r\n                    ex(\"NEWLINE\", \"Error\", \"let\")\r\n                    return res\r\n                pass\r\n            case _:\r\n                pass\r\n        match (cu().value):\r\n            case \"LET\":\r\n                ad(\"Let\")\r\n                # letを分析\r\n                # analyze let\r\n                Ident:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n                # ASS\r\n                ex(\"ASS\", \"The = operator is unknown\", \"Let\")\r\n                # numbers\r\n                com = comp(\"Let\")\r\n                res += com[0] + \"\\n\"\r\n                addlabel(Ident, \"Let\")\r\n                if isglobal():\r\n                    res += \"    \"*nowtab + f\"@{Ident.value} = {sz}*:global {sz}\\n\"\r\n                    res += \"    \"*nowtab + f\"void:store {sz}:@{com[1]}, {sz}*:@{Ident.value}\\n\"\r\n                else:\r\n                    res += \"    \"*nowtab + f\"%{Ident.value} = {sz}*:alloca {sz}\\n\"\r\n                    res += \"    \"*nowtab + f\"void:store {sz}:%{com[1]}, {sz}*:%{Ident.value}\\n\"\r\n                ex(\"NEWLINE\", \"Error\", \"let\")\r\n                print(labeldict[Scope[-1]])\r\n                return res\r\n            case \"FUNC\":\r\n                ad(\"Func\")\r\n                # Funcを分析\r\n                # analyze func\r\n                Ident:Token = ex(\"IDENT\", \"No function identifier\", \"Func\")\r\n                # Function Args\r\n                ex(\"LPAREN\", \"The syntax for naming function arguments is not complete\", \"Func\")\r\n                # name onlry\r\n                Args:list[Token] = []\r\n                while cu().type != \"RPAREN\":\r\n                    tok:Token = ex(\"IDENT\", \"The function arguments have not been declared\", \"Func\")\r\n                    Args.append(tok)\r\n                    if cu().type == \"RPAREN\":\r\n                        break\r\n                    ex(\"COMMA\", \"The function arguments have not COMMA\", \"Func\")\r\n                ex(\"RPAREN\", \"The syntax for naming function arguments is not complete\", \"Func\")\r\n                Addlabel(Ident.value, Ident, \"Func\")\r\n                res += \"    \"*nowtab + f\"define {sz}:@{Ident.value}({\"\".join([sz+ \":\" + i.value for i in Args])}) \"+ \"{\\n\"\r\n                nowtab += 1\r\n                res += \"    \"*nowtab + \"entry:\\n\"\r\n                nowtab += 1\r\n                for i in Args:\r\n                    addlabel(i, \"Let\")\r\n                ex(\"NEWLINE\", \"Error\", \"Func\")\r\n                print(labeldict)\r\n                print(Scope[-1])\r\n                return res\r\n            case \"RET\":\r\n                ad(\"RET\")\r\n                # Ret\r\n                com = comp(\"RET\")\r\n                res += com[0] + \"\\n\"\r\n                res += \"    \"*nowtab + f\"void:ret {sz}:%{com[1]}\\n\"\r\n                nowtab -= 2\r\n                res += \"    \"*nowtab + \"}\\n\"\r\n                ex(\"NEWLINE\", \"Error\", \"Func\")\r\n                delllabel(Scope[-1], \"Ret\")\r\n                return res\r\n            case \"IF\":\r\n                # if func\r\n                ad(\"IF\")\r\n                # \r\n            case _:\r\n                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                raise\r\n\r\n    def comp(name:str) -> tuple[str, int]:\r\n        addr:int = usepos()\r\n        isglobal_ = isglobal()\r\n        cur = cu()\r\n        scope = Getlabel()\r\n        ad(\"Compute\")\r\n        res = \"\"\r\n        # 数字\r\n        #Number\r\n        if cur.type == \"NUMBER\":\r\n            if isglobal_:\r\n                return \"    \"*nowtab + f\"@{addr} = {sz}*:global {sz}:{cur.value}\\n\",addr\r\n            return \"    \"*nowtab + f\"%{addr} = {cur.value}\\n\", addr\r\n        elif cur.type == \"IDENT\":\r\n            if isglobal_:\r\n                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n                raise\r\n            if cur.value in scope:\r\n                return \"    \"*nowtab + f\"%{addr} = {sz}:load {sz}*:%{cur.value}\\n\",addr\r\n            if cur.value in labeldict[\"Global\"]:\r\n                return \"    \"*nowtab + f\"%{addr} = {sz}:load {sz}*:@{cur.value}\\n\",addr\r\n            if cur.value in Function:\r\n                ex(\"LPAREN\", \"The syntax for naming function arguments is not complete\", \"callFunc\")\r\n                # anarlyz args\r\n                Args:list[Token] = []\r\n                while cu().type != \"RPAREN\":\r\n                    tok:Token = ex(\"IDENT\", \"The function arguments have not been declared\", \"callFunc\")\r\n                    Args.append(tok)\r\n                    if cu().type == \"RPAREN\":\r\n                        break\r\n                    ex(\"COMMA\", \"The function arguments have not COMMA\", \"callFunc\")\r\n                ex(\"RPAREN\", \"The syntax for naming function arguments is not complete\", \"callFunc\")\r\n                res += \"    \"*nowtab + f\"%{addr} = {sz}:call @{cur.value}({\"\".join([sz+ \"*:%\" + i.value for i in Args])}) \"\r\n                return res, addr\r\n            CallError(cur, \"The identifier could not be found\", f\"Compute-{name}\",source)\r\n            raise\r\n        elif cur.type == \"LPAREN\":\r\n            # 関数または演算子\r\n            # Function or Op\r\n            if cu().type == \"OP\":\r\n                # Op\r\n                cur = cu()\r\n                ad(f\"Compute-{name}\")\r\n                match (cur.value):\r\n                    case \"+\":\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        com1 = comp(f\"Compute-{name}\")\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        print(com1)\r\n                        while cu().type != \"RPAREN\":\r\n                            com2 = comp(f\"Compute-{name}\")\r\n                            res += com1[0] + \"\\n\"\r\n                            res += com2[0] + \"\\n\"\r\n                            if isglobal_:\r\n                                res += \"    \"*nowtab + f\"@{addr} = {sz}:add {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n                            else:\r\n                                res += \"    \"*nowtab + f\"%{addr} = {sz}:add {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n                            com1 = com2\r\n                            if cu().type == \"RPAREN\":\r\n                                break\r\n                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                            addr = usepos()\r\n                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n                        return res, addr\r\n                    case \"-\":\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        com1 = comp(f\"Compute-{name}\")\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        print(com1)\r\n                        while cu().type != \"RPAREN\":\r\n                            com2 = comp(f\"Compute-{name}\")\r\n                            res += com1[0] + \"\\n\"\r\n                            res += com2[0] + \"\\n\"\r\n                            if isglobal_:\r\n                                res += \"    \"*nowtab + f\"@{addr} = {sz}:sub {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n                            else:\r\n                                res += \"    \"*nowtab + f\"%{addr} = {sz}:sub {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n                            com1 = com2\r\n                            if cu().type == \"RPAREN\":\r\n                                break\r\n                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                            addr = usepos()\r\n                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n                        return res, addr\r\n                    case \"*\":\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        com1 = comp(f\"Compute-{name}\")\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        print(com1)\r\n                        while cu().type != \"RPAREN\":\r\n                            com2 = comp(f\"Compute-{name}\")\r\n                            res += com1[0] + \"\\n\"\r\n                            res += com2[0] + \"\\n\"\r\n                            if isglobal_:\r\n                                res += \"    \"*nowtab + f\"@{addr} = {sz}:mul {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n                            else:\r\n                                res += \"    \"*nowtab + f\"%{addr} = {sz}:mul {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n                            com1 = com2\r\n                            if cu().type == \"RPAREN\":\r\n                                break\r\n                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                            addr = usepos()\r\n                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n                        return res, addr\r\n                    case \"/\":\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        com1 = comp(f\"Compute-{name}\")\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        print(com1)\r\n                        while cu().type != \"RPAREN\":\r\n                            com2 = comp(f\"Compute-{name}\")\r\n                            res += com1[0] + \"\\n\"\r\n                            res += com2[0] + \"\\n\"\r\n                            if isglobal_:\r\n                                res += \"    \"*nowtab + f\"@{addr} = {sz}:divv {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n                            else:\r\n                                res += \"    \"*nowtab + f\"%{addr} = {sz}:divv {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n                            com1 = com2\r\n                            if cu().type == \"RPAREN\":\r\n                                break\r\n                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                            addr = usepos()\r\n                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n                        return res, addr\r\n                    case \"%\":\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        com1 = comp(f\"Compute-{name}\")\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        print(com1)\r\n                        while cu().type != \"RPAREN\":\r\n                            com2 = comp(f\"Compute-{name}\")\r\n                            res += com1[0] + \"\\n\"\r\n                            res += com2[0] + \"\\n\"\r\n                            if isglobal_:\r\n                                res += \"    \"*nowtab + f\"@{addr} = {sz}:divv {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n                            else:\r\n                                res += \"    \"*nowtab + f\"%{addr} = {sz}:divv {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n                            com1 = com2\r\n                            if cu().type == \"RPAREN\":\r\n                                break\r\n                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                            addr = usepos()\r\n                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n                        return res, addr\r\n                    case \"addr\":\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        com1 = comp(f\"Compute-{name}\")\r\n                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                        print(com1)\r\n                        while cu().type != \"RPAREN\":\r\n                            com2 = comp(f\"Compute-{name}\")\r\n                            res += com1[0] + \"\\n\"\r\n                            res += com2[0] + \"\\n\"\r\n                            if isglobal_:\r\n                                res += \"    \"*nowtab + f\"@{addr} = {sz}:gep {sz}:@{com1[1]}, {sz}:@{com2[1]}\\n\"\r\n                            else:\r\n                                res += \"    \"*nowtab + f\"%{addr} = {sz}:gep {sz}:%{com1[1]}, {sz}:%{com2[1]}\\n\"\r\n                            com1 = com2\r\n                            if cu().type == \"RPAREN\":\r\n                                break\r\n                            ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n                            addr = usepos()\r\n                        ex(\"RPAREN\", \"RPAREN missing; expression must be closed\", f\"Compute-{name}\")\r\n                        return res, addr\r\n                    case _:\r\n                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n                        raise\r\n            CallError(cur, \"unkwon\", f\"Compute-{name}\",source)\r\n            raise\r\n        CallError(cur, \"unkwon\", f\"Compute-{name}\",source)\r\n        raise\r\n    return stmt() + f\"\\n{sz}:call @main()\""
        }
    ]
}