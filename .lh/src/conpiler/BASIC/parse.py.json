{
    "sourceFile": "src/conpiler/BASIC/parse.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1761571637427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761571648154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,132 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str):\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        \r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571655195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n                 cur = cu()\r\n                 ad(f\"Compute-{name}\")\r\n                 match (cur.value):\r\n                     case \"+\":\r\n-                        \r\n+                        ex(\"COMMA\")\r\n                     case \"-\":\r\n                     case \"*\":\r\n                     case \"/\":\r\n                     case \"%\":\r\n@@ -128,137 +128,5 @@\n                     case _:\r\n                         CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n                         raise\r\n             # Function\r\n-    return stmt()\n-\"\"\"\r\n-IR設計を見直したためもう一度作成する\r\n-\r\n-\"\"\"\r\n-from __future__ import annotations\r\n-from array import array\r\n-import sys\r\n-from lexer import Token\r\n-from pathlib import Path\r\n-repo_root = Path(__file__).resolve().parents[2]\r\n-if str(repo_root) not in sys.path:\r\n-    sys.path.insert(0, str(repo_root))\r\n-import src.util as util\r\n-\r\n-def CallError(tok:Token, message:str, name:str, source:str):\r\n-    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n-\r\n-def parse(tokens:list[Token], source:str):\r\n-    pos = 0\r\n-    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n-    llabelpos = 0\r\n-    glabelpos = 0\r\n-    Scope:list[str] = [\"Global\"]\r\n-\r\n-    def usepos() -> int:\r\n-        nonlocal llabelpos, glabelpos\r\n-        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n-            glabelpos += 1\r\n-            return glabelpos\r\n-        llabelpos += 1\r\n-        return llabelpos\r\n-    \r\n-    def isglobal() -> bool:\r\n-        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n-    \r\n-    def Getlabel() -> dict[str,list[int]]:\r\n-        return labeldict[Scope[-1]]\r\n-    \r\n-    def ad(name:str):\r\n-        nonlocal pos\r\n-        pos += 1\r\n-        if len(tokens) <= pos:\r\n-            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n-            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n-\r\n-    def cu():\r\n-        return tokens[pos]\r\n-    \r\n-    def ex(tt:str, message:str, name:str):\r\n-        if tt != cu().type:\r\n-            CallError(cu(), message, name, source)\r\n-        res = cu()\r\n-        ad(name)\r\n-        return res\r\n-    \r\n-    def stmt() -> str:\r\n-        assembly = \"\"\r\n-        while cu().type != \"EOF\":\r\n-            exp = expr()\r\n-            assembly += exp\r\n-        return assembly\r\n-    \r\n-    def expr() -> str:\r\n-        # YkIR\r\n-        res = \"\"\r\n-        # 行を分析\r\n-        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n-        if cu().type == \"LINE_NUM\":\r\n-            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n-        else:\r\n-            # show what we actually have for easier debugging\r\n-            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n-            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n-            raise\r\n-        if (cu().type != \"KEYWORD\"):\r\n-            return \"\"\r\n-        res += f\"; LINE{linetok.value}\\n\"\r\n-        res += f\"LINE{linetok.value}:\\n\"\r\n-        match (cu().value):\r\n-            case \"LET\":\r\n-                ad(\"Let\")\r\n-                # letを分析\r\n-                # analyze let\r\n-                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n-                # ASS\r\n-                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n-                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n-                    raise\r\n-                # numbers\r\n-                \r\n-            case _:\r\n-                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n-                raise\r\n-\r\n-    def comp(name:str) -> tuple[str, int]:\r\n-        addr:int = usepos()\r\n-        isglobal_ = isglobal()\r\n-        cur = cu()\r\n-        scope = Getlabel()\r\n-        ad(\"Compute\")\r\n-        res = \"\"\r\n-        # 数字\r\n-        #Number\r\n-        if cur.type == \"NUMBER\":\r\n-            if isglobal_:\r\n-                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n-            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n-        elif cur.type == \"IDENT\":\r\n-            if isglobal_:\r\n-                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n-                raise\r\n-            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n-        elif cur.type == \"LPAREN\":\r\n-            # 関数または演算子\r\n-            # Function or Op\r\n-            if cu().type == \"OP\":\r\n-                # Op\r\n-                cur = cu()\r\n-                ad(f\"Compute-{name}\")\r\n-                match (cur.value):\r\n-                    case \"+\":\r\n-                        \r\n-                    case \"-\":\r\n-                    case \"*\":\r\n-                    case \"/\":\r\n-                    case \"%\":\r\n-                    case \"addr\":\r\n-                    case _:\r\n-                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n-                        raise\r\n-            # Function\r\n     return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571705250,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,132 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str):\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571712760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,137 +128,5 @@\n                     case _:\r\n                         CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n                         raise\r\n             # Function\r\n-    return stmt()\n-\"\"\"\r\n-IR設計を見直したためもう一度作成する\r\n-\r\n-\"\"\"\r\n-from __future__ import annotations\r\n-from array import array\r\n-import sys\r\n-from lexer import Token\r\n-from pathlib import Path\r\n-repo_root = Path(__file__).resolve().parents[2]\r\n-if str(repo_root) not in sys.path:\r\n-    sys.path.insert(0, str(repo_root))\r\n-import src.util as util\r\n-\r\n-def CallError(tok:Token, message:str, name:str, source:str):\r\n-    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n-\r\n-def parse(tokens:list[Token], source:str):\r\n-    pos = 0\r\n-    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n-    llabelpos = 0\r\n-    glabelpos = 0\r\n-    Scope:list[str] = [\"Global\"]\r\n-\r\n-    def usepos() -> int:\r\n-        nonlocal llabelpos, glabelpos\r\n-        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n-            glabelpos += 1\r\n-            return glabelpos\r\n-        llabelpos += 1\r\n-        return llabelpos\r\n-    \r\n-    def isglobal() -> bool:\r\n-        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n-    \r\n-    def Getlabel() -> dict[str,list[int]]:\r\n-        return labeldict[Scope[-1]]\r\n-    \r\n-    def ad(name:str):\r\n-        nonlocal pos\r\n-        pos += 1\r\n-        if len(tokens) <= pos:\r\n-            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n-            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n-\r\n-    def cu():\r\n-        return tokens[pos]\r\n-    \r\n-    def ex(tt:str, message:str, name:str):\r\n-        if tt != cu().type:\r\n-            CallError(cu(), message, name, source)\r\n-        res = cu()\r\n-        ad(name)\r\n-        return res\r\n-    \r\n-    def stmt() -> str:\r\n-        assembly = \"\"\r\n-        while cu().type != \"EOF\":\r\n-            exp = expr()\r\n-            assembly += exp\r\n-        return assembly\r\n-    \r\n-    def expr() -> str:\r\n-        # YkIR\r\n-        res = \"\"\r\n-        # 行を分析\r\n-        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n-        if cu().type == \"LINE_NUM\":\r\n-            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n-        else:\r\n-            # show what we actually have for easier debugging\r\n-            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n-            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n-            raise\r\n-        if (cu().type != \"KEYWORD\"):\r\n-            return \"\"\r\n-        res += f\"; LINE{linetok.value}\\n\"\r\n-        res += f\"LINE{linetok.value}:\\n\"\r\n-        match (cu().value):\r\n-            case \"LET\":\r\n-                ad(\"Let\")\r\n-                # letを分析\r\n-                # analyze let\r\n-                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n-                # ASS\r\n-                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n-                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n-                    raise\r\n-                # numbers\r\n-                \r\n-            case _:\r\n-                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n-                raise\r\n-\r\n-    def comp(name:str) -> tuple[str, int]:\r\n-        addr:int = usepos()\r\n-        isglobal_ = isglobal()\r\n-        cur = cu()\r\n-        scope = Getlabel()\r\n-        ad(\"Compute\")\r\n-        res = \"\"\r\n-        # 数字\r\n-        #Number\r\n-        if cur.type == \"NUMBER\":\r\n-            if isglobal_:\r\n-                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n-            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n-        elif cur.type == \"IDENT\":\r\n-            if isglobal_:\r\n-                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n-                raise\r\n-            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n-        elif cur.type == \"LPAREN\":\r\n-            # 関数または演算子\r\n-            # Function or Op\r\n-            if cu().type == \"OP\":\r\n-                # Op\r\n-                cur = cu()\r\n-                ad(f\"Compute-{name}\")\r\n-                match (cur.value):\r\n-                    case \"+\":\r\n-                        ex(\"COMMA\")\r\n-                    case \"-\":\r\n-                    case \"*\":\r\n-                    case \"/\":\r\n-                    case \"%\":\r\n-                    case \"addr\":\r\n-                    case _:\r\n-                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n-                        raise\r\n-            # Function\r\n     return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571727071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,132 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str):\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = anyi:imm {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571737137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n         # 数字\r\n         #Number\r\n         if cur.type == \"NUMBER\":\r\n             if isglobal_:\r\n-                return f\"@{addr} = anyi:imm {cur.value}\",addr\r\n+                return f\"@{addr} = anyi:global {cur.value}\",addr\r\n             return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n         elif cur.type == \"IDENT\":\r\n             if isglobal_:\r\n                 CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n@@ -128,137 +128,5 @@\n                     case _:\r\n                         CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n                         raise\r\n             # Function\r\n-    return stmt()\n-\"\"\"\r\n-IR設計を見直したためもう一度作成する\r\n-\r\n-\"\"\"\r\n-from __future__ import annotations\r\n-from array import array\r\n-import sys\r\n-from lexer import Token\r\n-from pathlib import Path\r\n-repo_root = Path(__file__).resolve().parents[2]\r\n-if str(repo_root) not in sys.path:\r\n-    sys.path.insert(0, str(repo_root))\r\n-import src.util as util\r\n-\r\n-def CallError(tok:Token, message:str, name:str, source:str):\r\n-    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n-\r\n-def parse(tokens:list[Token], source:str):\r\n-    pos = 0\r\n-    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n-    llabelpos = 0\r\n-    glabelpos = 0\r\n-    Scope:list[str] = [\"Global\"]\r\n-\r\n-    def usepos() -> int:\r\n-        nonlocal llabelpos, glabelpos\r\n-        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n-            glabelpos += 1\r\n-            return glabelpos\r\n-        llabelpos += 1\r\n-        return llabelpos\r\n-    \r\n-    def isglobal() -> bool:\r\n-        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n-    \r\n-    def Getlabel() -> dict[str,list[int]]:\r\n-        return labeldict[Scope[-1]]\r\n-    \r\n-    def ad(name:str):\r\n-        nonlocal pos\r\n-        pos += 1\r\n-        if len(tokens) <= pos:\r\n-            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n-            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n-\r\n-    def cu():\r\n-        return tokens[pos]\r\n-    \r\n-    def ex(tt:str, message:str, name:str):\r\n-        if tt != cu().type:\r\n-            CallError(cu(), message, name, source)\r\n-        res = cu()\r\n-        ad(name)\r\n-        return res\r\n-    \r\n-    def stmt() -> str:\r\n-        assembly = \"\"\r\n-        while cu().type != \"EOF\":\r\n-            exp = expr()\r\n-            assembly += exp\r\n-        return assembly\r\n-    \r\n-    def expr() -> str:\r\n-        # YkIR\r\n-        res = \"\"\r\n-        # 行を分析\r\n-        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n-        if cu().type == \"LINE_NUM\":\r\n-            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n-        else:\r\n-            # show what we actually have for easier debugging\r\n-            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n-            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n-            raise\r\n-        if (cu().type != \"KEYWORD\"):\r\n-            return \"\"\r\n-        res += f\"; LINE{linetok.value}\\n\"\r\n-        res += f\"LINE{linetok.value}:\\n\"\r\n-        match (cu().value):\r\n-            case \"LET\":\r\n-                ad(\"Let\")\r\n-                # letを分析\r\n-                # analyze let\r\n-                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n-                # ASS\r\n-                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n-                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n-                    raise\r\n-                # numbers\r\n-                \r\n-            case _:\r\n-                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n-                raise\r\n-\r\n-    def comp(name:str) -> tuple[str, int]:\r\n-        addr:int = usepos()\r\n-        isglobal_ = isglobal()\r\n-        cur = cu()\r\n-        scope = Getlabel()\r\n-        ad(\"Compute\")\r\n-        res = \"\"\r\n-        # 数字\r\n-        #Number\r\n-        if cur.type == \"NUMBER\":\r\n-            if isglobal_:\r\n-                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n-            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n-        elif cur.type == \"IDENT\":\r\n-            if isglobal_:\r\n-                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n-                raise\r\n-            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n-        elif cur.type == \"LPAREN\":\r\n-            # 関数または演算子\r\n-            # Function or Op\r\n-            if cu().type == \"OP\":\r\n-                # Op\r\n-                cur = cu()\r\n-                ad(f\"Compute-{name}\")\r\n-                match (cur.value):\r\n-                    case \"+\":\r\n-                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n-                    case \"-\":\r\n-                    case \"*\":\r\n-                    case \"/\":\r\n-                    case \"%\":\r\n-                    case \"addr\":\r\n-                    case _:\r\n-                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n-                        raise\r\n-            # Function\r\n     return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571754145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,132 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, ):\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = anyi:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571778364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,135 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : \r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = anyi:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571795437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,136 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : in\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = anyi:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571832032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,136 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = a:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571840803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,8 +25,10 @@\n     llabelpos = 0\r\n     glabelpos = 0\r\n     Scope:list[str] = [\"Global\"]\r\n \r\n+    \r\n+\r\n     def usepos() -> int:\r\n         nonlocal llabelpos, glabelpos\r\n         if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n             glabelpos += 1\r\n"
                },
                {
                    "date": 1761571854888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz =  if size == -1 else\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {}:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571860308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {}:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571866847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {}:global {cur.value}\",addr\r\n+            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571879968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,9 @@\n         # 数字\r\n         #Number\r\n         if cur.type == \"NUMBER\":\r\n             if isglobal_:\r\n-                return f\"@{addr} = {}:global {cur.value}\",addr\r\n+                return f\"@{addr} = {sz}:global {cur.value}\",addr\r\n             return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n         elif cur.type == \"IDENT\":\r\n             if isglobal_:\r\n                 CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n"
                },
                {
                    "date": 1761571890674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,9 @@\n         # 数字\r\n         #Number\r\n         if cur.type == \"NUMBER\":\r\n             if isglobal_:\r\n-                return f\"@{addr} = {sz}:global {cur.value}\",addr\r\n+                return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n             return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n         elif cur.type == \"IDENT\":\r\n             if isglobal_:\r\n                 CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n"
                },
                {
                    "date": 1761571902987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n+            return f\"%{addr} = \", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761571910112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n+            return f\"%{addr} = {sz}:alloca\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761572036260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n+            return f\"%{addr} = {sz}:alloca\\nstore <型> <値>, <型>* <変数アドレス>\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761572053630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n+            return f\"%{addr} = {sz}:alloca\\nstore i32 42, i32* %a\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761572060356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n         #Number\r\n         if cur.type == \"NUMBER\":\r\n             if isglobal_:\r\n                 return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n-            return f\"%{addr} = {sz}:alloca\\nstore i32 42, i32* %a\", addr\r\n+            return f\"%{addr} = {sz}:alloca\\nvoid:store i32 42, i32* %a\", addr\r\n         elif cur.type == \"IDENT\":\r\n             if isglobal_:\r\n                 CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n                 raise\r\n"
                },
                {
                    "date": 1761572073504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n         #Number\r\n         if cur.type == \"NUMBER\":\r\n             if isglobal_:\r\n                 return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n-            return f\"%{addr} = {sz}:alloca\\nvoid:store :i32 42, i32* %a\", addr\r\n+            return f\"%{addr} = {sz}:alloca\\nstore :i32 42, i32* %a\", addr\r\n         elif cur.type == \"IDENT\":\r\n             if isglobal_:\r\n                 CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n                 raise\r\n"
                },
                {
                    "date": 1761572089295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+\"\"\"\r\n+IR設計を見直したためもう一度作成する\r\n+\r\n+\"\"\"\r\n+from __future__ import annotations\r\n+from array import array\r\n+import sys\r\n+from lexer import Token\r\n+from pathlib import Path\r\n+repo_root = Path(__file__).resolve().parents[2]\r\n+if str(repo_root) not in sys.path:\r\n+    sys.path.insert(0, str(repo_root))\r\n+import src.util as util\r\n+\r\n+def CallError(tok:Token, message:str, name:str, source:str):\r\n+    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n+\r\n+def parse(tokens:list[Token], source:str, size:int):\r\n+    \"\"\"\r\n+    size -1 : anyi\r\n+    size n : i n\r\n+    \"\"\"\r\n+    pos = 0\r\n+    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n+    llabelpos = 0\r\n+    glabelpos = 0\r\n+    Scope:list[str] = [\"Global\"]\r\n+\r\n+    sz = \"anyi\" if size == -1 else f\"i{size}\"\r\n+\r\n+    def usepos() -> int:\r\n+        nonlocal llabelpos, glabelpos\r\n+        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n+            glabelpos += 1\r\n+            return glabelpos\r\n+        llabelpos += 1\r\n+        return llabelpos\r\n+    \r\n+    def isglobal() -> bool:\r\n+        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n+    \r\n+    def Getlabel() -> dict[str,list[int]]:\r\n+        return labeldict[Scope[-1]]\r\n+    \r\n+    def ad(name:str):\r\n+        nonlocal pos\r\n+        pos += 1\r\n+        if len(tokens) <= pos:\r\n+            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n+            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n+\r\n+    def cu():\r\n+        return tokens[pos]\r\n+    \r\n+    def ex(tt:str, message:str, name:str):\r\n+        if tt != cu().type:\r\n+            CallError(cu(), message, name, source)\r\n+        res = cu()\r\n+        ad(name)\r\n+        return res\r\n+    \r\n+    def stmt() -> str:\r\n+        assembly = \"\"\r\n+        while cu().type != \"EOF\":\r\n+            exp = expr()\r\n+            assembly += exp\r\n+        return assembly\r\n+    \r\n+    def expr() -> str:\r\n+        # YkIR\r\n+        res = \"\"\r\n+        # 行を分析\r\n+        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n+        if cu().type == \"LINE_NUM\":\r\n+            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n+        else:\r\n+            # show what we actually have for easier debugging\r\n+            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n+            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n+            raise\r\n+        if (cu().type != \"KEYWORD\"):\r\n+            return \"\"\r\n+        res += f\"; LINE{linetok.value}\\n\"\r\n+        res += f\"LINE{linetok.value}:\\n\"\r\n+        match (cu().value):\r\n+            case \"LET\":\r\n+                ad(\"Let\")\r\n+                # letを分析\r\n+                # analyze let\r\n+                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n+                # ASS\r\n+                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n+                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n+                    raise\r\n+                # numbers\r\n+                \r\n+            case _:\r\n+                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n+                raise\r\n+\r\n+    def comp(name:str) -> tuple[str, int]:\r\n+        addr:int = usepos()\r\n+        isglobal_ = isglobal()\r\n+        cur = cu()\r\n+        scope = Getlabel()\r\n+        ad(\"Compute\")\r\n+        res = \"\"\r\n+        # 数字\r\n+        #Number\r\n+        if cur.type == \"NUMBER\":\r\n+            if isglobal_:\r\n+                return f\"@{addr} = {sz}:global {sz}:{cur.value}\",addr\r\n+            return f\"%{addr} = {sz}:alloca\\nstore {sz}:{cur.value}, {sz}* %a\", addr\r\n+        elif cur.type == \"IDENT\":\r\n+            if isglobal_:\r\n+                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n+                raise\r\n+            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n+        elif cur.type == \"LPAREN\":\r\n+            # 関数または演算子\r\n+            # Function or Op\r\n+            if cu().type == \"OP\":\r\n+                # Op\r\n+                cur = cu()\r\n+                ad(f\"Compute-{name}\")\r\n+                match (cur.value):\r\n+                    case \"+\":\r\n+                        ex(\"COMMA\", \", does not exist\", f\"Compute-{name}\")\r\n+                    case \"-\":\r\n+                    case \"*\":\r\n+                    case \"/\":\r\n+                    case \"%\":\r\n+                    case \"addr\":\r\n+                    case _:\r\n+                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n+                        raise\r\n+            # Function\r\n+    return stmt()\n\\ No newline at end of file\n"
                }
            ],
            "date": 1761571637427,
            "name": "Commit-0",
            "content": "\"\"\"\r\nIR設計を見直したためもう一度作成する\r\n\r\n\"\"\"\r\nfrom __future__ import annotations\r\nfrom array import array\r\nimport sys\r\nfrom lexer import Token\r\nfrom pathlib import Path\r\nrepo_root = Path(__file__).resolve().parents[2]\r\nif str(repo_root) not in sys.path:\r\n    sys.path.insert(0, str(repo_root))\r\nimport src.util as util\r\n\r\ndef CallError(tok:Token, message:str, name:str, source:str):\r\n    raise util.ParseError(message, tok.lineno,tok.col,source, name)\r\n\r\ndef parse(tokens:list[Token], source:str):\r\n    pos = 0\r\n    labeldict:dict[str,dict[str,list[int]]] = {} # Scope:{name : mode,addr}\r\n    llabelpos = 0\r\n    glabelpos = 0\r\n    Scope:list[str] = [\"Global\"]\r\n\r\n    def usepos() -> int:\r\n        nonlocal llabelpos, glabelpos\r\n        if Scope[-1] == \"Global\" and len(Scope) == 1:\r\n            glabelpos += 1\r\n            return glabelpos\r\n        llabelpos += 1\r\n        return llabelpos\r\n    \r\n    def isglobal() -> bool:\r\n        return Scope[-1] == \"Global\" and len(Scope) == 1\r\n    \r\n    def Getlabel() -> dict[str,list[int]]:\r\n        return labeldict[Scope[-1]]\r\n    \r\n    def ad(name:str):\r\n        nonlocal pos\r\n        pos += 1\r\n        if len(tokens) <= pos:\r\n            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n            CallError(tokens[pos-1], \"Error! Out of range\", name, source)\r\n\r\n    def cu():\r\n        return tokens[pos]\r\n    \r\n    def ex(tt:str, message:str, name:str):\r\n        if tt != cu().type:\r\n            CallError(cu(), message, name, source)\r\n        res = cu()\r\n        ad(name)\r\n        return res\r\n    \r\n    def stmt() -> str:\r\n        assembly = \"\"\r\n        while cu().type != \"EOF\":\r\n            exp = expr()\r\n            assembly += exp\r\n        return assembly\r\n    \r\n    def expr() -> str:\r\n        # YkIR\r\n        res = \"\"\r\n        # 行を分析\r\n        # Accept either a LINE_NUM token or a plain NUMBER (some lexers emit NUMBER for line labels)\r\n        if cu().type == \"LINE_NUM\":\r\n            linetok = ex(\"LINE_NUM\", \"is not line number\", \"Expr\")\r\n        else:\r\n            # show what we actually have for easier debugging\r\n            print(\"expected LINE_NUM or NUMBER, got\", cu())\r\n            CallError(cu(), \"NEW LINE TOKEN is missing\", \"expr\", source)\r\n            raise\r\n        if (cu().type != \"KEYWORD\"):\r\n            return \"\"\r\n        res += f\"; LINE{linetok.value}\\n\"\r\n        res += f\"LINE{linetok.value}:\\n\"\r\n        match (cu().value):\r\n            case \"LET\":\r\n                ad(\"Let\")\r\n                # letを分析\r\n                # analyze let\r\n                IDNET:Token = ex(\"IDENT\", \"An identifier is required.\", \"Let\")\r\n                # ASS\r\n                if ex(\"OP\", \"The = operator is unknown\", \"Let\").value != \"=\":\r\n                    CallError(cu(), \"The = operator is unknown\", \"Let\",source)\r\n                    raise\r\n                # numbers\r\n                \r\n            case _:\r\n                CallError(cu(), f\"unkonw token {cu()}\", \"expr-end\", source)\r\n                raise\r\n\r\n    def comp(name:str) -> tuple[str, int]:\r\n        addr:int = usepos()\r\n        isglobal_ = isglobal()\r\n        cur = cu()\r\n        scope = Getlabel()\r\n        ad(\"Compute\")\r\n        res = \"\"\r\n        # 数字\r\n        #Number\r\n        if cur.type == \"NUMBER\":\r\n            if isglobal_:\r\n                return f\"${addr} = anyi:imm {cur.value}\",addr\r\n            return f\"%{addr} = anyi:imm {cur.value}\", addr\r\n        elif cur.type == \"IDENT\":\r\n            if isglobal_:\r\n                CallError(cur, \"Variable usage is only allowed within the scope.\", f\"Compute-{name}\",source)\r\n                raise\r\n            return f\"%{addr} = anyi:alloca\\nstore :\\n\",addr\r\n        elif cur.type == \"LPAREN\":\r\n            # 関数または演算子\r\n            # Function or Op\r\n            if cu().type == \"OP\":\r\n                # Op\r\n                cur = cu()\r\n                ad(f\"Compute-{name}\")\r\n                match (cur.value):\r\n                    case \"+\":\r\n                        \r\n                    case \"-\":\r\n                    case \"*\":\r\n                    case \"/\":\r\n                    case \"%\":\r\n                    case \"addr\":\r\n                    case _:\r\n                        CallError(cur, f\"unkwon Token {cur}\", f\"Compute-{name}\", source)\r\n                        raise\r\n            # Function\r\n    return stmt()"
        }
    ]
}