{
    "sourceFile": "src/conpiler/ASIC/parse.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1760351792246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760351803748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n             assembly+=f\"{expr()}\\n\"\r\n             ex(\"NEWLINE\", \"is not have line\")\r\n         return assembly\r\n     def expr():\r\n-        nonlocal line, \r\n+        nonlocal line, nextlevel\r\n         # アセンブリ\r\n         res = \"\"\r\n         # 行を分析\r\n         linetok = ex(\"LINE_NUM\", \"is not line number\")\r\n"
                },
                {
                    "date": 1760352491459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,8 @@\n     useingaddress:list[int] = []\r\n     useingaddress+=addr\r\n     useingreg: list[int] = reg\r\n     Variable:dict[str,int] = {} # 名前:番地\r\n-    nextlevel:int = 0\r\n     def ad():\r\n         nonlocal pos\r\n         pos += 1\r\n         if len(tokens) <= pos:\r\n"
                },
                {
                    "date": 1760352498930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,9 +168,8 @@\n                     print(\"NOT HAVE 'TO'\")\r\n                     return \"\"\r\n                 computed = compute()\r\n                 # レジスタを開放\r\n-                nextlevel += 1\r\n                 res += stmt()\r\n             case \"PRINT\":\r\n                 pass\r\n             case \"INPUT\":\r\n"
                },
                {
                    "date": 1760352583906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n             assembly+=f\"{expr()}\\n\"\r\n             ex(\"NEWLINE\", \"is not have line\")\r\n         return assembly\r\n     def expr():\r\n-        nonlocal line,\r\n+        nonlocal line\r\n         # アセンブリ\r\n         res = \"\"\r\n         # 行を分析\r\n         linetok = ex(\"LINE_NUM\", \"is not line number\")\r\n"
                },
                {
                    "date": 1760363661187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,8 +169,9 @@\n                     return \"\"\r\n                 computed = compute()\r\n                 # レジスタを開放\r\n                 res += stmt()\r\n+            case \r\n             case \"PRINT\":\r\n                 pass\r\n             case \"INPUT\":\r\n                 pass\r\n"
                }
            ],
            "date": 1760351792246,
            "name": "Commit-0",
            "content": "\"\"\"\r\nlexerからのものを解析しYkIRを出力\r\n構文:\r\nLET 変数名 = 式\r\n\r\n(+,1,2)で区切る\r\n\r\nIF 式 比較記号 式 THEN 番号 ELSE 番号\r\n\r\n\"\"\"\r\nfrom lexer import Token\r\n\r\ndef parse(source:str, tokens:list[Token], addr:list[int] = [], reg:list[int] = []):\r\n    pos:int = 0\r\n    line:list[str] = []\r\n    useingaddress:list[int] = []\r\n    useingaddress+=addr\r\n    useingreg: list[int] = reg\r\n    Variable:dict[str,int] = {} # 名前:番地\r\n    nextlevel:int = 0\r\n    def ad():\r\n        nonlocal pos\r\n        pos += 1\r\n        if len(tokens) <= pos:\r\n            print(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n            raise RuntimeError(f\"out of range of pos. now pos token:{tokens[pos-1]}\")\r\n    def cu():\r\n        return tokens[pos]\r\n    def ex(tt:str, message:str):\r\n        if tt != cu().type:\r\n            print(message, cu())\r\n            raise RuntimeError(f\"{message}{cu()}\")\r\n        res = cu()\r\n        ad()\r\n        return res\r\n    def allocmem():\r\n        n = 0\r\n        while True:\r\n            if n not in useingaddress:\r\n                useingaddress.append(n)\r\n                return n\r\n            n += 1\r\n    def freemem(number:int):\r\n        useingaddress.pop(useingaddress.index(number))\r\n    def allocreg():\r\n        n = 0\r\n        while True:\r\n            if n not in useingreg:\r\n                useingreg.append(n)\r\n                return n\r\n            n += 1\r\n    def freereg(number:int):\r\n        useingreg.pop(useingreg.index(number))\r\n    def stmt():\r\n        assembly = \"\"\r\n        while cu().type != \"EOF\":\r\n            assembly+=f\"{expr()}\\n\"\r\n            ex(\"NEWLINE\", \"is not have line\")\r\n        return assembly\r\n    def expr():\r\n        nonlocal line, \r\n        # アセンブリ\r\n        res = \"\"\r\n        # 行を分析\r\n        linetok = ex(\"LINE_NUM\", \"is not line number\")\r\n        line += [linetok.value]\r\n        if (cu().type != \"KEYWORD\"):\r\n            return \"\"\r\n        res += f\"; LINE{linetok.value}\\n\"\r\n        res += f\"LINE{linetok.value}:\\n\"\r\n        match (cu().value):\r\n            case \"LET\":\r\n                ad()\r\n                mem = allocmem()\r\n                ident = ex(\"IDENT\", \"is not indent\")\r\n                op = ex(\"OP\", \"is not op\")\r\n                if op.value != \"=\":\r\n                    raise RuntimeError(f\"is not op{op}\")\r\n                computed = compute()\r\n                res += computed[0]\r\n                res += \"\\n\"\r\n                # メモリにセット\r\n                res += f\"; memset\\nSET {mem}, r{computed[1][0]}\\n\"\r\n                # 設定\r\n                Variable[ident.value] = mem\r\n                return res\r\n            case \"IF\":\r\n                ad()\r\n                cm = cmp()\r\n                res += cm[0]\r\n                res += \"\\n\"\r\n                # THENトークン\r\n                if not ex(\"KEYWORD\", \"THEN is no\").value == \"THEN\":\r\n                    print(\"THEN is no\")\r\n                    raise RuntimeError\r\n                number1 = ex(\"NUMBER\", \"number is no\")\r\n                flag = cu().value == \"ELSE\"\r\n                number2 = tokens[0]\r\n                if flag:\r\n                    ad()\r\n                    number2 = ex(\"NUMBER\", \"number is no\")\r\n                match(cm[1].value):\r\n                    case \"==\":\r\n                        # JE\r\n                        res += f\"; je to then number\\n\"\r\n                        res += f\"JE LINE{number1.value}\\n\"\r\n                        if flag:\r\n                            res += f\"; jmp to else\\n\"\r\n                            res += f\"JMP LINE{number2.value}\\n\"\r\n                    case \"!=\":\r\n                        # JNE\r\n                        res += f\"; je to then number\\n\"\r\n                        res += f\"JNE LINE{number1.value}\\n\"\r\n                        if flag:\r\n                            res += f\"; jmp to else\\n\"\r\n                            res += f\"JMP LINE{number2.value}\\n\"\r\n                    case \">\":\r\n                        # JA\r\n                        res += f\"; je to then number\\n\"\r\n                        res += f\"JA LINE{number1.value}\\n\"\r\n                        if flag:\r\n                            res += f\"; jmp to else\\n\"\r\n                            res += f\"JMP LINE{number2.value}\\n\"\r\n                    case \"<\":\r\n                        # JNAE\r\n                        res += f\"; je to then number\\n\"\r\n                        res += f\"JNAE LINE{number1.value}\\n\"\r\n                        if flag:\r\n                            res += f\"; jmp to else\\n\"\r\n                            res += f\"JMP LINE{number2.value}\\n\"\r\n                    case \">=\":\r\n                        # JAE\r\n                        res += f\"; je to then number\\n\"\r\n                        res += f\"JAE LINE{number1.value}\\n\"\r\n                        if flag:\r\n                            res += f\"; jmp to else\\n\"\r\n                            res += f\"JMP LINE{number2.value}\\n\"\r\n                    case \"<=\":\r\n                        # JNA\r\n                        res += f\"; je to then number\\n\"\r\n                        res += f\"JNA LINE{number1.value}\\n\"\r\n                        if flag:\r\n                            res += f\"; jmp to else\\n\"\r\n                            res += f\"JMP LINE{number2.value}\\n\"\r\n                    case _:\r\n                        return \"\"\r\n                return res\r\n            case \"GOTO\":\r\n                ad()\r\n                numtok = ex(\"NUMBER\", \"number is no\")\r\n                res += f\"; goto{numtok.value}\\n\"\r\n                res += f\"JMP LINE{numtok.value}\\n\"\r\n                return res\r\n            case \"FOR\":\r\n                ad()\r\n                mem = allocmem()\r\n                nametok = ex(\"IDENT\", \"NOT HAVE IDENT\")\r\n                if not ex(\"OP\", \"NOT HAVE =\").value == \"=\":\r\n                    print(\"NOT HAVE =\")\r\n                    return \"\"\r\n                # 式\r\n                computed = compute()\r\n                res += \"; FOR INDENT\\n\"\r\n                res += f\"SET {mem}, {computed[1][0]}\"\r\n                freereg(computed[1][0])\r\n                Variable[nametok.value] = mem\r\n                # 次\r\n                if not ex(\"KEYWORD\", \"NOTHAVE 'TO'\").value == \"TO\":\r\n                    print(\"NOT HAVE 'TO'\")\r\n                    return \"\"\r\n                computed = compute()\r\n                # レジスタを開放\r\n                nextlevel += 1\r\n                res += stmt()\r\n            case \"PRINT\":\r\n                pass\r\n            case \"INPUT\":\r\n                pass\r\n            case \"END\":\r\n                # HALT\r\n                return \"; Halt\\nHLT\"\r\n            case \"GOSUB\":\r\n                pass\r\n            case \"RETURN\":\r\n                pass\r\n            case \"STEP\":\r\n                pass\r\n            case \"TO\":\r\n                pass\r\n            case \"REM\":\r\n                pass\r\n            case \"AND\":\r\n                pass\r\n            case \"OR\":\r\n                pass\r\n            case \"NOT\":\r\n                pass\r\n            case _:\r\n                # パスする\r\n                return \"\"\r\n    def cmp():\r\n        res = \"\"\r\n        a = compute()\r\n        op = cu()\r\n        ad()\r\n        b = compute()\r\n        res += f\"; CMP A B\\n\"\r\n        res += f\"{a[0]}\"\r\n        res += f\"{b[0]}\"\r\n        res += \"; CMP\\n\"\r\n        res += f\"CMP r{a[1][0]}, r{b[1][0]}\"\r\n        freereg(a[1][0])\r\n        freereg(b[1][0])\r\n        return (res, op)\r\n\r\n    def compute() -> tuple[str, list[int]]:\r\n        res = \"\"\r\n\r\n        regs = [allocreg()]\r\n        # 初期化\r\n        res += f\"; SetZero\\nLOAD r{regs[0]}, 0\\n\"\r\n        if cu().type == \"IDENT\":\r\n            print(\"inent\")\r\n            res = f\"; Get a memory\\nGET r{regs[0]}, {Variable[cu().value]}\\n\"\r\n            ad()\r\n            return (res, [regs[0]])\r\n        elif cu().type == \"NUMBER\":\r\n            print(\"number\")\r\n            res = f\"; Set a number\\nLOAD r{regs[0]}, {cu().value}\\n\"\r\n            ad()\r\n            return (res, [regs[0]])\r\n        else:\r\n            # トークン消費\r\n            ex(\"LPAREN\", \"There is no left parenthesis ( LPAREN. \")\r\n            # 計算をする\r\n            optok = cu()\r\n            ad()\r\n            print(\"op\")\r\n            # +,14,a\r\n            # ,消費\r\n            ex(\"COMMA\", \"is no left parenthesis , COMMA\")\r\n            if optok.type == \"CMPOP\":\r\n                #別の処理\r\n                pass\r\n            else:\r\n                while cu().type != \"RPAREN\":\r\n                    print(regs)\r\n                    computed = compute()\r\n                    regs += computed[1]\r\n                    res += computed[0]\r\n                    match (optok.value):\r\n                        case \"+\":\r\n                            res += f\"; ADD\\nADD r{regs[0]}, r{regs[1]}, r{regs[0]}\\n\"\r\n                            freereg(regs[1])\r\n                        case \"-\":\r\n                            res += f\"; SUB\\nSUB r{regs[0]}, r{regs[1]}, r{regs[0]}\\n\"\r\n                            freereg(regs[1])\r\n                        case \"*\":\r\n                            res += f\"; MUL\\nMUL r{regs[0]}, r{regs[1]}, r{regs[0]}\\n\"\r\n                            freereg(regs[1])\r\n                        case \"/\":\r\n                            res += f\"; DIV\\nDIV r{regs[0]}, r{regs[1]}, r{regs[0]}\\n\"\r\n                            freereg(regs[1])\r\n                        case \"MOD\":\r\n                            res += f\"; MOD\\nMOD r{regs[0]}, r{regs[1]}, r{regs[0]}\\n\"\r\n                            freereg(regs[1])\r\n                        case _:\r\n                            raise RuntimeError\r\n                    if cu().type == \"RPAREN\":\r\n                        break\r\n                    ex(\"COMMA\", \"is no left parenthesis , COMMA\")\r\n                    regs.pop()\r\n            # トークン消費\r\n            ex(\"RPAREN\", \"There is no left parenthesis ) RPAREN.\")\r\n            print(regs)\r\n            return (res, regs)\r\n    return stmt()"
        }
    ]
}